<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CTM Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-deep: #0a0e14;
            --bg-panel: #111820;
            --bg-hover: #1a2230;
            --text-primary: #f0f4f8;
            --text-secondary: #a0b0c0;
            --text-dim: #6a7a8a;
            --accent-blue: #4a9eff;
            --accent-cyan: #00d4aa;
            --accent-orange: #ff9f43;
            --accent-pink: #ff6b9d;
            --neuron-glow: #4a9eff;
            --connection-base: #2a3a4a;
        }

        body {
            background: var(--bg-deep);
            color: var(--text-primary);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .main-container {
            flex: 1;
            display: flex;
            padding: 20px;
            gap: 20px;
            min-height: 0;
        }

        /* Left Panel - Input & Attention */
        .left-panel {
            width: 280px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        /* Confidence Section */
        .confidence-section {
            text-align: center;
        }

        .confidence-value {
            font-size: 36px;
            font-weight: 700;
            font-family: 'SF Mono', 'Consolas', monospace;
            background: linear-gradient(135deg, var(--accent-cyan) 0%, var(--accent-blue) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 12px;
        }

        .confidence-bar {
            height: 10px;
            background: var(--bg-deep);
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-blue));
            transition: width 0.3s ease;
        }

        .confidence-label {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .panel {
            background: var(--bg-panel);
            border-radius: 12px;
            padding: 20px;
        }

        .panel-title {
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-secondary);
            margin-bottom: 16px;
        }

        .input-display {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-bottom: 16px;
        }

        .input-number {
            width: 56px;
            height: 56px;
            background: var(--bg-deep);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .input-number input {
            width: 100%;
            height: 100%;
            background: transparent;
            border: none;
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 24px;
            font-weight: 600;
            font-family: 'SF Mono', 'Consolas', monospace;
            text-align: center;
            outline: none;
        }

        .input-number input:focus {
            box-shadow: 0 0 0 2px var(--accent-blue);
        }

        .input-number .attn-bar {
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            height: 3px;
            background: var(--accent-cyan);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .arrow-symbol {
            display: flex;
            align-items: center;
            font-size: 24px;
            color: var(--text-dim);
        }

        .prediction-box {
            width: 56px;
            height: 56px;
            background: linear-gradient(135deg, var(--accent-cyan) 0%, var(--accent-blue) 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: 700;
            font-family: 'SF Mono', 'Consolas', monospace;
        }

        /* Attention Panel - expanded */
        .attention-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .attention-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .attention-head {
            flex: 1;
        }

        .attention-head-label {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 10px;
            font-weight: 500;
        }

        .attention-rows {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .attention-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .attention-pos {
            font-size: 12px;
            font-family: 'SF Mono', 'Consolas', monospace;
            color: var(--text-dim);
            width: 24px;
        }

        .attention-input-val {
            font-size: 14px;
            font-family: 'SF Mono', 'Consolas', monospace;
            color: var(--text-primary);
            background: var(--bg-deep);
            padding: 4px 8px;
            border-radius: 4px;
            min-width: 28px;
            text-align: center;
        }

        .attention-bar-container {
            flex: 1;
            height: 24px;
            background: var(--bg-deep);
            border-radius: 4px;
            overflow: hidden;
        }

        .attention-bar-fill {
            height: 100%;
            background: var(--accent-cyan);
            transition: width 0.3s ease;
            opacity: 0.8;
        }

        .attention-weight {
            font-size: 13px;
            font-family: 'SF Mono', 'Consolas', monospace;
            color: var(--text-secondary);
            width: 36px;
            text-align: right;
        }

        /* Center Panel - Network */
        .center-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .network-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        #networkCanvas {
            width: 100%;
            height: 100%;
        }

        /* Confidence Chart at bottom center */
        .confidence-chart-container {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            background: var(--bg-panel);
            border-radius: 12px;
            padding: 12px 16px;
        }

        /* Right Panel - Detail View */
        .right-panel {
            width: 320px;
            display: flex;
            flex-direction: column;
        }

        /* Detail Panel - full height with modern scrollbar */
        .detail-panel {
            flex: 1;
            background: var(--bg-deep);
            border-radius: 8px;
            padding: 16px;
            overflow-y: auto;
        }

        /* Modern scrollbar styling */
        .detail-panel::-webkit-scrollbar {
            width: 8px;
        }

        .detail-panel::-webkit-scrollbar-track {
            background: var(--bg-deep);
            border-radius: 4px;
        }

        .detail-panel::-webkit-scrollbar-thumb {
            background: var(--text-dim);
            border-radius: 4px;
        }

        .detail-panel::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        /* Model Card */
        .model-card {
            background: var(--bg-panel);
            border-radius: 12px;
            padding: 16px 20px;
            margin-top: auto;
        }

        .model-card-content {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .detail-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--accent-cyan);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .detail-close {
            margin-left: auto;
            cursor: pointer;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .detail-close:hover {
            opacity: 1;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid var(--bg-panel);
            font-size: 14px;
        }

        .detail-row:last-child {
            border-bottom: none;
        }

        .detail-label {
            color: var(--text-dim);
        }

        .detail-value {
            font-family: 'SF Mono', 'Consolas', monospace;
            color: var(--text-primary);
        }

        .matrix-display {
            margin-top: 12px;
            background: var(--bg-panel);
            border-radius: 6px;
            padding: 10px;
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 11px;
            overflow-x: auto;
        }

        .matrix-row {
            display: flex;
            gap: 4px;
        }

        .matrix-cell {
            min-width: 40px;
            text-align: right;
            padding: 2px 4px;
            border-radius: 2px;
        }

        .matrix-cell.positive {
            background: rgba(0, 212, 170, 0.2);
            color: var(--accent-cyan);
        }

        .matrix-cell.negative {
            background: rgba(255, 107, 157, 0.2);
            color: var(--accent-pink);
        }

        /* Control Dock */
        .control-dock {
            background: var(--bg-panel);
            padding: 16px 24px;
            display: flex;
            justify-content: center;
            gap: 32px;
            border-top: 1px solid var(--bg-hover);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-key {
            min-width: 36px;
            height: 36px;
            background: var(--bg-deep);
            border: 1px solid var(--text-dim);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-family: 'SF Mono', 'Consolas', monospace;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .control-key:hover {
            border-color: var(--accent-blue);
            color: var(--accent-blue);
        }

        .control-key.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: var(--bg-deep);
        }

        .control-label {
            font-size: 16px;
            color: var(--text-secondary);
        }

        .preset-keys {
            display: flex;
            gap: 4px;
        }

        .preset-key {
            width: 32px;
            height: 32px;
            font-size: 13px;
        }

        /* Hidden state */
        .hidden {
            display: none !important;
        }

        /* Loading */
        .loading {
            position: fixed;
            inset: 0;
            background: var(--bg-deep);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-text {
            font-size: 18px;
            color: var(--text-secondary);
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="loading-text">Loading CTM...</div>
    </div>

    <div class="main-container">
        <!-- Left Panel -->
        <div class="left-panel">
            <div class="panel">
                <div class="panel-title">Input → Output</div>
                <div class="input-display">
                    <div class="input-number">
                        <input type="text" id="input0" maxlength="2" value="2">
                        <div class="attn-bar" style="width: 0%"></div>
                    </div>
                    <div class="input-number">
                        <input type="text" id="input1" maxlength="2" value="4">
                        <div class="attn-bar" style="width: 0%"></div>
                    </div>
                    <div class="input-number">
                        <input type="text" id="input2" maxlength="2" value="6">
                        <div class="attn-bar" style="width: 0%"></div>
                    </div>
                    <div class="arrow-symbol">→</div>
                    <div class="prediction-box" id="predictionBox">8</div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-title">Confidence</div>
                <div class="confidence-section">
                    <div class="confidence-value" id="confidenceText">97.0%</div>
                    <div class="confidence-bar">
                        <div class="confidence-fill" id="confidenceFill" style="width: 97%"></div>
                    </div>
                    <div class="confidence-label">Tick <span id="tickValue">1</span> of 6</div>
                </div>
            </div>

            <div class="panel attention-panel">
                <div class="panel-title">Attention</div>
                <div class="attention-section">
                    <div class="attention-head">
                        <div class="attention-head-label">Head 0</div>
                        <div class="attention-rows" id="attnHead0">
                            <div class="attention-row">
                                <span class="attention-pos">P0</span>
                                <span class="attention-input-val" data-pos="0">2</span>
                                <div class="attention-bar-container">
                                    <div class="attention-bar-fill" style="width: 33%"></div>
                                </div>
                                <span class="attention-weight">0.33</span>
                            </div>
                            <div class="attention-row">
                                <span class="attention-pos">P1</span>
                                <span class="attention-input-val" data-pos="1">4</span>
                                <div class="attention-bar-container">
                                    <div class="attention-bar-fill" style="width: 33%"></div>
                                </div>
                                <span class="attention-weight">0.33</span>
                            </div>
                            <div class="attention-row">
                                <span class="attention-pos">P2</span>
                                <span class="attention-input-val" data-pos="2">6</span>
                                <div class="attention-bar-container">
                                    <div class="attention-bar-fill" style="width: 33%"></div>
                                </div>
                                <span class="attention-weight">0.33</span>
                            </div>
                        </div>
                    </div>
                    <div class="attention-head">
                        <div class="attention-head-label">Head 1</div>
                        <div class="attention-rows" id="attnHead1">
                            <div class="attention-row">
                                <span class="attention-pos">P0</span>
                                <span class="attention-input-val" data-pos="0">2</span>
                                <div class="attention-bar-container">
                                    <div class="attention-bar-fill" style="width: 33%"></div>
                                </div>
                                <span class="attention-weight">0.33</span>
                            </div>
                            <div class="attention-row">
                                <span class="attention-pos">P1</span>
                                <span class="attention-input-val" data-pos="1">4</span>
                                <div class="attention-bar-container">
                                    <div class="attention-bar-fill" style="width: 33%"></div>
                                </div>
                                <span class="attention-weight">0.33</span>
                            </div>
                            <div class="attention-row">
                                <span class="attention-pos">P2</span>
                                <span class="attention-input-val" data-pos="2">6</span>
                                <div class="attention-bar-container">
                                    <div class="attention-bar-fill" style="width: 33%"></div>
                                </div>
                                <span class="attention-weight">0.33</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="model-card">
                <div class="panel-title">Model</div>
                <div class="model-card-content">
                    7,999 parameters · 12 neurons · 78 sync pairs · 6 ticks
                </div>
            </div>
        </div>

        <!-- Center Panel -->
        <div class="center-panel">
            <div class="network-container">
                <canvas id="networkCanvas"></canvas>
            </div>
            <div class="confidence-chart-container">
                <div class="panel-title" style="text-align: center; margin-bottom: 8px;">Confidence Over Ticks</div>
                <canvas id="confidenceChart" height="80"></canvas>
            </div>
        </div>

        <!-- Right Panel - Detail View -->
        <div class="right-panel">
            <div class="panel" style="flex: 1; display: flex; flex-direction: column;">
                <div class="panel-title">Detail View</div>
                <div class="detail-panel" id="detailPanel">
                    <div style="color: var(--text-secondary); font-size: 16px;">
                        Click a neuron or connection to inspect
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Control Dock -->
    <div class="control-dock">
        <div class="control-group">
            <div class="control-key" id="keyLeft">←</div>
            <div class="control-key" id="keyRight">→</div>
            <div class="control-label">Step through ticks</div>
        </div>

        <div class="control-group">
            <div class="control-key" id="keySpace" style="min-width: 64px;">Space</div>
            <div class="control-label">Play / Pause</div>
        </div>

        <div class="control-group">
            <div class="preset-keys">
                <div class="control-key preset-key" data-preset="1">1</div>
                <div class="control-key preset-key" data-preset="2">2</div>
                <div class="control-key preset-key" data-preset="3">3</div>
                <div class="control-key preset-key" data-preset="4">4</div>
                <div class="control-key preset-key" data-preset="5">5</div>
            </div>
            <div class="control-label">Load preset (step 1-5)</div>
        </div>

        <div class="control-group">
            <div class="control-key" id="keyPredict">P</div>
            <div class="control-label">Jump to prediction</div>
        </div>
    </div>

    <script>
        // ============================================================
        // CTM Inference Engine (embedded)
        // ============================================================
        
        class CTMInference {
            constructor(modelData) {
                this.config = modelData.config;
                this.weights = modelData.weights;
                this.syncIndices = this.computeSyncIndices();
            }

            computeSyncIndices() {
                const d = this.config.d_model;
                const indices = [];
                for (let i = 0; i < d; i++) {
                    for (let j = i; j < d; j++) {
                        indices.push([i, j]);
                    }
                }
                return indices;
            }

            zeros(shape) {
                if (shape.length === 1) return new Array(shape[0]).fill(0);
                if (shape.length === 2) return Array.from({ length: shape[0] }, () => new Array(shape[1]).fill(0));
                return Array.from({ length: shape[0] }, () => this.zeros(shape.slice(1)));
            }

            clone(arr) { return JSON.parse(JSON.stringify(arr)); }
            add(a, b) { return typeof a === 'number' ? a + b : a.map((v, i) => this.add(v, b[i])); }
            dot(a, b) { return a.reduce((sum, v, i) => sum + v * b[i], 0); }
            matvec(A, x) { return A.map(row => this.dot(row, x)); }
            softmax(x) {
                const max = Math.max(...x);
                const exp = x.map(v => Math.exp(v - max));
                const sum = exp.reduce((a, b) => a + b, 0);
                return exp.map(v => v / sum);
            }
            softplus(x) { return typeof x === 'number' ? Math.log(1 + Math.exp(x)) : x.map(v => Math.log(1 + Math.exp(v))); }
            relu(x) { return typeof x === 'number' ? Math.max(0, x) : x.map(v => this.relu(v)); }
            concat(a, b) { return [...a, ...b]; }

            linear(x, weight, bias) {
                const out = this.matvec(weight, x);
                return this.add(out, bias);
            }

            layerNorm(x, weight, bias, eps = 1e-5) {
                const mean = x.reduce((a, b) => a + b, 0) / x.length;
                const variance = x.reduce((a, b) => a + (b - mean) ** 2, 0) / x.length;
                const std = Math.sqrt(variance + eps);
                return x.map((v, i) => ((v - mean) / std) * weight[i] + bias[i]);
            }

            embedding(indices, table) { return indices.map(i => [...table[i]]); }

            computeSync(postActHistory) {
                const T = postActHistory.length;
                const decayRates = this.softplus(this.weights.decay);
                
                const timeWeights = [];
                for (let t = 0; t < T; t++) {
                    const tBack = T - 1 - t;
                    timeWeights.push(decayRates.map(d => Math.exp(-d * tBack)));
                }
                
                const sync = new Array(this.config.d_sync).fill(0);
                for (let s = 0; s < this.syncIndices.length; s++) {
                    const [i, j] = this.syncIndices[s];
                    let weightedSum = 0, weightSum = 0;
                    for (let t = 0; t < T; t++) {
                        const product = postActHistory[t][i] * postActHistory[t][j];
                        const w = timeWeights[t][s];
                        weightedSum += product * w;
                        weightSum += w;
                    }
                    sync[s] = weightedSum / (weightSum + 1e-8);
                }
                return sync;
            }

            nlmForward(preActHistory) {
                const { d_model, memory_length, nlm_hidden } = this.config;
                const output = [];
                
                for (let neuron = 0; neuron < d_model; neuron++) {
                    const history = preActHistory[neuron];
                    const hidden = new Array(nlm_hidden).fill(0);
                    
                    for (let hi = 0; hi < nlm_hidden; hi++) {
                        let sum = this.weights.nlm_b1[neuron][hi];
                        for (let mi = 0; mi < memory_length; mi++) {
                            sum += history[mi] * this.weights.nlm_w1[neuron][mi][hi];
                        }
                        hidden[hi] = Math.max(0, sum);
                    }
                    
                    let out = this.weights.nlm_b2[neuron][0];
                    for (let hi = 0; hi < nlm_hidden; hi++) {
                        out += hidden[hi] * this.weights.nlm_w2[neuron][hi][0];
                    }
                    output.push(out);
                }
                return output;
            }

            synapse(z, attnOut) {
                const input = this.concat(z, attnOut);
                let h = this.linear(input, this.weights.synapse_0_weight, this.weights.synapse_0_bias);
                h = this.layerNorm(h, this.weights.synapse_1_weight, this.weights.synapse_1_bias);
                h = this.relu(h);
                h = this.linear(h, this.weights.synapse_3_weight, this.weights.synapse_3_bias);
                return h;
            }

            forward(numbers, returnInternals = false) {
                const { seq_length, d_model, n_heads, head_dim, memory_length, n_ticks } = this.config;
                
                const numEmb = this.embedding(numbers, this.weights.num_embed);
                const posEmb = this.embedding([0, 1, 2].slice(0, seq_length), this.weights.pos_embed);
                const embeddings = numEmb.map((ne, i) => this.add(ne, posEmb[i]));
                
                const kvFeatures = embeddings.map(emb => 
                    this.linear(emb, this.weights.kv_proj_weight, this.weights.kv_proj_bias)
                );
                
                const K = [], V = [];
                for (let h = 0; h < n_heads; h++) {
                    const kHead = [], vHead = [];
                    for (let s = 0; s < seq_length; s++) {
                        const headStart = h * head_dim * 2;
                        kHead.push(kvFeatures[s].slice(headStart, headStart + head_dim));
                        vHead.push(kvFeatures[s].slice(headStart + head_dim, headStart + head_dim * 2));
                    }
                    K.push(kHead);
                    V.push(vHead);
                }
                
                let z = this.clone(this.weights.z_init);
                let preActHistory = this.clone(this.weights.pre_act_history_init);
                const postActHistory = [this.clone(z)];
                const outputs = [];
                
                const internals = returnInternals ? {
                    postActivations: [],
                    sync: [],
                    attentionWeights: [],
                    preActHistory: [],
                    predictions: [],
                    confidences: []
                } : null;
                
                for (let t = 0; t < n_ticks; t++) {
                    const sync = this.computeSync(postActHistory);
                    const qFlat = this.linear(sync, this.weights.q_proj_weight, this.weights.q_proj_bias);
                    
                    const Q = [];
                    for (let h = 0; h < n_heads; h++) {
                        Q.push([qFlat.slice(h * head_dim, (h + 1) * head_dim)]);
                    }
                    
                    const attnWeightsAllHeads = [];
                    const attnOutPerHead = [];
                    
                    for (let h = 0; h < n_heads; h++) {
                        const scores = [];
                        for (let s = 0; s < seq_length; s++) {
                            scores.push(this.dot(Q[h][0], K[h][s]) / Math.sqrt(head_dim));
                        }
                        const attnWeights = this.softmax(scores);
                        attnWeightsAllHeads.push(attnWeights);
                        
                        const attnOut = new Array(head_dim).fill(0);
                        for (let s = 0; s < seq_length; s++) {
                            for (let d = 0; d < head_dim; d++) {
                                attnOut[d] += attnWeights[s] * V[h][s][d];
                            }
                        }
                        attnOutPerHead.push(attnOut);
                    }
                    
                    const attnConcat = attnOutPerHead.flat();
                    const attnOut = this.linear(attnConcat, this.weights.attn_out_proj_weight, this.weights.attn_out_proj_bias);
                    const preAct = this.synapse(z, attnOut);
                    
                    for (let n = 0; n < d_model; n++) {
                        for (let m = 0; m < memory_length - 1; m++) {
                            preActHistory[n][m] = preActHistory[n][m + 1];
                        }
                        preActHistory[n][memory_length - 1] = preAct[n];
                    }
                    
                    z = this.nlmForward(preActHistory);
                    postActHistory.push(this.clone(z));
                    
                    const finalSync = this.computeSync(postActHistory);
                    const logits = this.linear(finalSync, this.weights.output_proj_weight, this.weights.output_proj_bias);
                    outputs.push(logits);
                    
                    if (internals) {
                        internals.postActivations.push(this.clone(z));
                        internals.sync.push(this.clone(finalSync));
                        internals.attentionWeights.push(this.clone(attnWeightsAllHeads));
                        internals.preActHistory.push(this.clone(preActHistory));
                        
                        const probs = this.softmax(logits);
                        const predIdx = logits.indexOf(Math.max(...logits));
                        internals.predictions.push(predIdx + 1);
                        internals.confidences.push(probs[predIdx]);
                    }
                }
                
                const finalLogits = outputs[outputs.length - 1];
                const probs = this.softmax(finalLogits);
                const predIdx = finalLogits.indexOf(Math.max(...finalLogits));
                
                return { outputs, prediction: predIdx + 1, confidence: probs[predIdx], internals };
            }

            getSyncPairInfo(pairIndex) {
                const [i, j] = this.syncIndices[pairIndex];
                const decay = this.softplus([this.weights.decay[pairIndex]])[0];
                return { neuronI: i, neuronJ: j, decayRate: decay, isSelf: i === j };
            }

            getNeuronNLMWeights(neuronIndex) {
                return {
                    w1: this.weights.nlm_w1[neuronIndex],
                    b1: this.weights.nlm_b1[neuronIndex],
                    w2: this.weights.nlm_w2[neuronIndex],
                    b2: this.weights.nlm_b2[neuronIndex]
                };
            }
        }

        // ============================================================
        // Visualizer Application
        // ============================================================
        
        class CTMVisualizer {
            constructor() {
                this.ctm = null;
                this.currentInput = [2, 4, 6];
                this.currentTick = 0;
                this.maxTicks = 6;
                this.inferenceResult = null;
                this.isPlaying = false;
                this.playInterval = null;
                this.selectedNeuron = null;
                this.selectedConnection = null;
                this.hoveredNeuron = null;
                this.hoveredConnection = null;
                
                this.presets = {
                    1: [1, 2, 3],
                    2: [2, 4, 6],
                    3: [3, 6, 9],
                    4: [4, 8, 12],
                    5: [5, 10, 15]
                };
                
                this.canvas = document.getElementById('networkCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.neuronPositions = [];
                this.connectionPaths = [];
            }

            async init() {
                try {
                    const response = await fetch('model_weights.json');
                    const modelData = await response.json();
                    this.ctm = new CTMInference(modelData);
                    
                    this.setupCanvas();
                    this.setupEventListeners();
                    this.runInference();
                    this.render();
                    
                    document.getElementById('loading').classList.add('hidden');
                } catch (error) {
                    console.error('Failed to load model:', error);
                    document.getElementById('loading').innerHTML = 
                        '<div class="loading-text">Failed to load model. Ensure model_weights.json is in the same directory.</div>';
                }
            }

            setupCanvas() {
                const container = this.canvas.parentElement;
                const dpr = window.devicePixelRatio || 1;
                
                const resize = () => {
                    const rect = container.getBoundingClientRect();
                    this.canvas.width = rect.width * dpr;
                    this.canvas.height = rect.height * dpr;
                    this.canvas.style.width = rect.width + 'px';
                    this.canvas.style.height = rect.height + 'px';
                    this.ctx.scale(dpr, dpr);
                    this.canvasWidth = rect.width;
                    this.canvasHeight = rect.height;
                    this.calculatePositions();
                    this.render();
                };
                
                resize();
                window.addEventListener('resize', resize);
            }

            calculatePositions() {
                // 3D parameters - horizontal cylinder (time flows left to right)
                this.rotationX = -15;  // Slight tilt down to see depth
                this.rotationY = 50;   // Start at max clockwise rotation
                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                
                // Cylinder dimensions
                const cx = this.canvasWidth / 2;
                const cy = this.canvasHeight / 2 - 70;  // Shifted up to balance space above/below
                this.centerX = cx;
                this.centerY = cy;
                this.circleRadius = Math.min(cx * 0.35, cy - 80) * 0.9;  // Radius of neuron circle
                this.layerSpacing = 50;  // Horizontal spacing between tick layers
                
                // Build connection paths (same for all ticks)
                this.connectionPaths = [];
                for (let i = 0; i < 12; i++) {
                    for (let j = i; j < 12; j++) {
                        this.connectionPaths.push({
                            i, j,
                            isSelf: i === j,
                            syncIndex: this.connectionPaths.length
                        });
                    }
                }
                
                this.updateProjectedPositions();
            }
            
            updateProjectedPositions() {
                // Convert rotation to radians
                const radX = this.rotationX * Math.PI / 180;
                const radY = this.rotationY * Math.PI / 180;
                
                // Precompute trig
                const cosX = Math.cos(radX);
                const sinX = Math.sin(radX);
                const cosY = Math.cos(radY);
                const sinY = Math.sin(radY);
                
                // Calculate 3D positions for all neurons on all ticks
                // neuronPositions3D[tick][neuronIdx] = {x, y, z, screenX, screenY}
                this.neuronPositions3D = [];
                
                for (let tick = 0; tick < this.maxTicks; tick++) {
                    const tickPositions = [];
                    // X position: tick 0 at left, tick 5 at right
                    // Center the cylinder horizontally
                    const xBase = (tick - (this.maxTicks - 1) / 2) * this.layerSpacing;
                    
                    for (let i = 0; i < 12; i++) {
                        const angle = (i / 12) * Math.PI * 2 - Math.PI / 2;
                        
                        // 3D position (before rotation)
                        // Circle is in Y-Z plane, time progresses along X
                        let x = xBase;
                        let y = Math.cos(angle) * this.circleRadius;
                        let z = Math.sin(angle) * this.circleRadius;
                        
                        // Apply Y rotation (spin around vertical axis)
                        const x1 = x * cosY - z * sinY;
                        const z1 = x * sinY + z * cosY;
                        x = x1;
                        z = z1;
                        
                        // Apply X rotation (tilt forward/back)
                        const y1 = y * cosX - z * sinX;
                        const z2 = y * sinX + z * cosX;
                        y = y1;
                        z = z2;
                        
                        // Project to screen (simple orthographic with slight perspective)
                        const scale = 1 + z * 0.001;  // Subtle perspective
                        const screenX = this.centerX + x * scale;
                        const screenY = this.centerY + y * scale;
                        
                        tickPositions.push({
                            x3d: x, y3d: y, z3d: z,
                            x: screenX,
                            y: screenY,
                            depth: z,  // For sorting
                            angle
                        });
                    }
                    this.neuronPositions3D.push(tickPositions);
                }
                
                // For backwards compatibility, keep neuronPositions as current tick
                this.neuronPositions = this.neuronPositions3D[this.currentTick] || this.neuronPositions3D[0];
            }

            setupEventListeners() {
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                this.canvas.addEventListener('mouseleave', () => {
                    this.hoveredNeuron = null;
                    this.hoveredConnection = null;
                    this.isDragging = false;
                    this.render();
                });
                
                // Drag rotation
                this.canvas.addEventListener('mousedown', (e) => {
                    // Only start drag if not over a neuron/connection
                    if (this.hoveredNeuron === null && this.hoveredConnection === null) {
                        this.isDragging = true;
                        this.lastMouseX = e.clientX;
                        this.lastMouseY = e.clientY;
                        this.canvas.style.cursor = 'grabbing';
                    }
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    this.canvas.style.cursor = 'default';
                });
                
                document.querySelectorAll('.preset-key').forEach(key => {
                    key.addEventListener('click', () => {
                        const preset = parseInt(key.dataset.preset);
                        this.loadPreset(preset);
                    });
                });
                
                document.getElementById('keyLeft').addEventListener('click', () => this.stepTick(-1));
                document.getElementById('keyRight').addEventListener('click', () => this.stepTick(1));
                document.getElementById('keySpace').addEventListener('click', () => this.togglePlay());
                document.getElementById('keyPredict').addEventListener('click', () => this.jumpToPrediction());
                
                // Input field listeners
                for (let i = 0; i < 3; i++) {
                    const input = document.getElementById(`input${i}`);
                    input.addEventListener('change', () => this.loadFromInputFields());
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            this.loadFromInputFields();
                            input.blur();
                        }
                    });
                }
            }

            handleKeyDown(e) {
                if (e.target.tagName === 'INPUT') return;
                
                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        this.stepTick(-1);
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        this.stepTick(1);
                        break;
                    case ' ':
                        e.preventDefault();
                        this.togglePlay();
                        break;
                    case '1': case '2': case '3': case '4': case '5':
                        this.loadPreset(parseInt(e.key));
                        break;
                    case 'p': case 'P':
                        this.jumpToPrediction();
                        break;
                }
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Handle drag rotation
                if (this.isDragging) {
                    const deltaX = e.clientX - this.lastMouseX;
                    const deltaY = e.clientY - this.lastMouseY;
                    
                    // Flip both directions so dragging feels like grabbing the front
                    this.rotationY -= deltaX * 0.5;
                    this.rotationX -= deltaY * 0.3;
                    
                    // Clamp rotations (Y: 20 to 80, starting at 50)
                    this.rotationY = Math.max(20, Math.min(80, this.rotationY));
                    this.rotationX = Math.max(-45, Math.min(-5, this.rotationX));
                    
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                    
                    this.updateProjectedPositions();
                    this.render();
                    return;
                }
                
                this.hoveredNeuron = null;
                this.hoveredConnection = null;
                
                // Only check current tick layer for hover
                const currentPositions = this.neuronPositions3D[this.currentTick];
                
                // Check neurons first
                for (let i = 0; i < currentPositions.length; i++) {
                    const pos = currentPositions[i];
                    const dist = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
                    if (dist < 30) {
                        this.hoveredNeuron = i;
                        this.canvas.style.cursor = 'pointer';
                        this.render();
                        return;
                    }
                }
                
                // Check connections on current tick
                for (const conn of this.connectionPaths) {
                    if (conn.isSelf) continue;
                    const p1 = currentPositions[conn.i];
                    const p2 = currentPositions[conn.j];
                    const dist = this.pointToLineDistance(x, y, p1.x, p1.y, p2.x, p2.y);
                    if (dist < 8) {
                        this.hoveredConnection = conn;
                        this.canvas.style.cursor = 'pointer';
                        this.render();
                        return;
                    }
                }
                
                this.canvas.style.cursor = this.isDragging ? 'grabbing' : 'grab';
                this.render();
            }

            pointToLineDistance(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let t = lenSq !== 0 ? dot / lenSq : -1;
                t = Math.max(0, Math.min(1, t));
                
                const nearestX = x1 + t * C;
                const nearestY = y1 + t * D;
                
                return Math.sqrt((px - nearestX) ** 2 + (py - nearestY) ** 2);
            }

            handleClick(e) {
                if (this.hoveredNeuron !== null) {
                    this.selectedNeuron = this.hoveredNeuron;
                    this.selectedConnection = null;
                    this.showNeuronDetail(this.selectedNeuron);
                } else if (this.hoveredConnection !== null) {
                    this.selectedConnection = this.hoveredConnection;
                    this.selectedNeuron = null;
                    this.showConnectionDetail(this.selectedConnection);
                } else {
                    this.selectedNeuron = null;
                    this.selectedConnection = null;
                    this.clearDetail();
                }
                this.render();
            }

            loadPreset(n) {
                document.querySelectorAll('.preset-key').forEach(k => k.classList.remove('active'));
                document.querySelector(`.preset-key[data-preset="${n}"]`).classList.add('active');
                
                this.currentInput = [...this.presets[n]];
                document.getElementById('input0').value = this.currentInput[0];
                document.getElementById('input1').value = this.currentInput[1];
                document.getElementById('input2').value = this.currentInput[2];
                
                this.runInference();
                this.setTick(0);
            }

            loadFromInputFields() {
                const a = parseInt(document.getElementById('input0').value) || 1;
                const b = parseInt(document.getElementById('input1').value) || 2;
                const c = parseInt(document.getElementById('input2').value) || 3;
                
                document.querySelectorAll('.preset-key').forEach(k => k.classList.remove('active'));
                
                this.currentInput = [
                    Math.max(1, Math.min(55, a)),
                    Math.max(1, Math.min(55, b)),
                    Math.max(1, Math.min(55, c))
                ];
                
                // Update fields with clamped values
                document.getElementById('input0').value = this.currentInput[0];
                document.getElementById('input1').value = this.currentInput[1];
                document.getElementById('input2').value = this.currentInput[2];
                
                this.runInference();
                this.setTick(0);
            }

            runInference() {
                this.inferenceResult = this.ctm.forward(this.currentInput, true);
                this.updateUI();
            }

            stepTick(delta) {
                this.setTick(Math.max(0, Math.min(this.maxTicks - 1, this.currentTick + delta)));
            }

            setTick(tick) {
                this.currentTick = tick;
                this.updateProjectedPositions();
                this.updateUI();
                this.render();
            }

            jumpToPrediction() {
                if (!this.inferenceResult) return;
                
                // Find tick with maximum confidence (first one in case of tie)
                const confidences = this.inferenceResult.internals.confidences;
                let maxConf = -1;
                let bestTick = 0;
                
                for (let t = 0; t < confidences.length; t++) {
                    if (confidences[t] > maxConf) {
                        maxConf = confidences[t];
                        bestTick = t;
                    }
                }
                
                this.setTick(bestTick);
                
                // Brief highlight on the P button
                const btn = document.getElementById('keyPredict');
                btn.classList.add('active');
                setTimeout(() => btn.classList.remove('active'), 300);
            }

            togglePlay() {
                this.isPlaying = !this.isPlaying;
                document.getElementById('keySpace').classList.toggle('active', this.isPlaying);
                
                if (this.isPlaying) {
                    this.playInterval = setInterval(() => {
                        this.currentTick = (this.currentTick + 1) % this.maxTicks;
                        this.setTick(this.currentTick);
                    }, 800);
                } else {
                    clearInterval(this.playInterval);
                }
            }

            updateUI() {
                if (!this.inferenceResult) return;
                
                const tick = this.currentTick;
                const internals = this.inferenceResult.internals;
                
                const pred = internals.predictions[tick];
                const conf = internals.confidences[tick];
                
                document.getElementById('predictionBox').textContent = pred;
                document.getElementById('confidenceFill').style.width = (conf * 100) + '%';
                document.getElementById('confidenceText').textContent = (conf * 100).toFixed(1) + '%';
                document.getElementById('tickValue').textContent = tick + 1;
                
                const attnWeights = internals.attentionWeights[tick];
                this.updateAttentionDisplay(attnWeights);
                
                this.updateConfidenceChart();
                
                if (this.selectedNeuron !== null) {
                    this.showNeuronDetail(this.selectedNeuron);
                } else if (this.selectedConnection !== null) {
                    this.showConnectionDetail(this.selectedConnection);
                }
            }

            updateAttentionDisplay(attnWeights) {
                for (let h = 0; h < 2; h++) {
                    const container = document.getElementById(`attnHead${h}`);
                    const rows = container.querySelectorAll('.attention-row');
                    
                    for (let i = 0; i < 3; i++) {
                        const weight = attnWeights[h][i];
                        const row = rows[i];
                        row.querySelector('.attention-bar-fill').style.width = (weight * 100) + '%';
                        row.querySelector('.attention-weight').textContent = weight.toFixed(2);
                        row.querySelector('.attention-input-val').textContent = this.currentInput[i];
                    }
                }
                
                const avgAttn = attnWeights[0].map((w, i) => (w + attnWeights[1][i]) / 2);
                for (let i = 0; i < 3; i++) {
                    const inputEl = document.getElementById(`input${i}`);
                    inputEl.parentElement.querySelector('.attn-bar').style.width = (avgAttn[i] * 100) + '%';
                }
            }

            updateConfidenceChart() {
                const canvas = document.getElementById('confidenceChart');
                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                ctx.scale(dpr, dpr);
                
                const width = rect.width;
                const height = rect.height;
                const paddingLeft = 15;
                const paddingRight = 50;
                const paddingY = 20;
                const chartWidth = width - paddingLeft - paddingRight;
                const chartHeight = height - paddingY * 2;
                
                ctx.clearRect(0, 0, width, height);
                
                ctx.strokeStyle = '#2a3a4a';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(paddingLeft, height - paddingY);
                ctx.lineTo(width - paddingRight, height - paddingY);
                ctx.stroke();
                
                const confs = this.inferenceResult.internals.confidences;
                const stepX = chartWidth / (confs.length - 1);
                
                ctx.strokeStyle = '#4a9eff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < confs.length; i++) {
                    const x = paddingLeft + i * stepX;
                    const y = height - paddingY - confs[i] * chartHeight;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                for (let i = 0; i < confs.length; i++) {
                    const x = paddingLeft + i * stepX;
                    const y = height - paddingY - confs[i] * chartHeight;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, i === this.currentTick ? 6 : 4, 0, Math.PI * 2);
                    ctx.fillStyle = i === this.currentTick ? '#00d4aa' : '#4a9eff';
                    ctx.fill();
                }
            }

            showNeuronDetail(neuronIdx) {
                const tick = this.currentTick;
                const internals = this.inferenceResult.internals;
                const activation = internals.postActivations[tick][neuronIdx];
                const nlmWeights = this.ctm.getNeuronNLMWeights(neuronIdx);
                const history = internals.preActHistory[tick][neuronIdx];
                
                let html = `
                    <div class="detail-title">
                        <span>Neuron ${neuronIdx}</span>
                        <span class="detail-close" onclick="visualizer.clearDetail()">✕</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Activation</span>
                        <span class="detail-value">${activation.toFixed(4)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">NLM Hidden</span>
                        <span class="detail-value">6 units</span>
                    </div>
                    <div style="margin-top: 12px; font-size: 11px; color: var(--text-secondary);">
                        Memory Buffer (last 4 pre-activations)
                    </div>
                    <div class="matrix-display">
                        <div class="matrix-row">
                            ${history.map(v => `<div class="matrix-cell ${v >= 0 ? 'positive' : 'negative'}">${v.toFixed(2)}</div>`).join('')}
                        </div>
                    </div>
                    <div style="margin-top: 12px; font-size: 11px; color: var(--text-secondary);">
                        NLM W1 [4×6]
                    </div>
                    <div class="matrix-display">
                        ${nlmWeights.w1.map(row => `
                            <div class="matrix-row">
                                ${row.map(v => `<div class="matrix-cell ${v >= 0 ? 'positive' : 'negative'}">${v.toFixed(2)}</div>`).join('')}
                            </div>
                        `).join('')}
                    </div>
                `;
                
                document.getElementById('detailPanel').innerHTML = html;
            }

            showConnectionDetail(conn) {
                const tick = this.currentTick;
                const internals = this.inferenceResult.internals;
                const syncValue = internals.sync[tick][conn.syncIndex];
                const pairInfo = this.ctm.getSyncPairInfo(conn.syncIndex);
                
                const actI = internals.postActivations[tick][conn.i];
                const actJ = internals.postActivations[tick][conn.j];
                
                let html = `
                    <div class="detail-title">
                        <span>Sync Pair ${conn.i}↔${conn.j}</span>
                        <span class="detail-close" onclick="visualizer.clearDetail()">✕</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Sync Value</span>
                        <span class="detail-value">${syncValue.toFixed(4)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Decay Rate</span>
                        <span class="detail-value">${pairInfo.decayRate.toFixed(4)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Neuron ${conn.i} activation</span>
                        <span class="detail-value">${actI.toFixed(4)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Neuron ${conn.j} activation</span>
                        <span class="detail-value">${actJ.toFixed(4)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Product (current)</span>
                        <span class="detail-value">${(actI * actJ).toFixed(4)}</span>
                    </div>
                    <div style="margin-top: 12px; font-size: 11px; color: var(--text-dim);">
                        Sync = weighted correlation of activations over time, with exponential decay (rate ${pairInfo.decayRate.toFixed(2)})
                    </div>
                `;
                
                document.getElementById('detailPanel').innerHTML = html;
            }

            clearDetail() {
                this.selectedNeuron = null;
                this.selectedConnection = null;
                document.getElementById('detailPanel').innerHTML = `
                    <div style="color: var(--text-secondary); font-size: 16px;">
                        Click a neuron or connection to inspect
                    </div>
                `;
                this.render();
            }

            render() {
                const ctx = this.ctx;
                const width = this.canvasWidth;
                const height = this.canvasHeight;
                
                ctx.clearRect(0, 0, width, height);
                
                if (!this.inferenceResult) return;
                
                const currentTick = this.currentTick;
                const internals = this.inferenceResult.internals;
                
                // Collect all renderable items with depth for sorting
                const renderItems = [];
                
                // Build render items for each tick layer
                for (let tick = 0; tick < this.maxTicks; tick++) {
                    const isCurrentTick = tick === currentTick;
                    const layerAlpha = isCurrentTick ? 1.0 : 0.15;
                    const positions = this.neuronPositions3D[tick];
                    
                    const syncValues = internals.sync[tick];
                    const activations = internals.postActivations[tick];
                    const maxSync = Math.max(...syncValues.map(Math.abs));
                    const maxAct = Math.max(...activations.map(Math.abs));
                    
                    // Average depth of this layer for sorting
                    const layerDepth = positions.reduce((sum, p) => sum + p.depth, 0) / positions.length;
                    
                    // Add connections for this tick
                    for (const conn of this.connectionPaths) {
                        if (conn.isSelf) continue;
                        
                        const p1 = positions[conn.i];
                        const p2 = positions[conn.j];
                        const syncVal = syncValues[conn.syncIndex];
                        const normalizedSync = maxSync > 0 ? Math.abs(syncVal) / maxSync : 0;
                        
                        const isSelected = isCurrentTick && this.selectedConnection && 
                                           this.selectedConnection.syncIndex === conn.syncIndex;
                        const isHovered = isCurrentTick && this.hoveredConnection && 
                                          this.hoveredConnection.syncIndex === conn.syncIndex;
                        
                        renderItems.push({
                            type: 'connection',
                            depth: (p1.depth + p2.depth) / 2,
                            tick,
                            draw: () => {
                                let alpha = (0.1 + normalizedSync * 0.6) * layerAlpha;
                                let lineWidth = 1 + normalizedSync * 3;
                                
                                if (isSelected || isHovered) {
                                    alpha = 1;
                                    lineWidth += 2;
                                }
                                
                                const hue = syncVal >= 0 ? 175 : 340;
                                ctx.strokeStyle = `hsla(${hue}, 80%, 60%, ${alpha})`;
                                ctx.lineWidth = lineWidth;
                                
                                ctx.beginPath();
                                ctx.moveTo(p1.x, p1.y);
                                ctx.lineTo(p2.x, p2.y);
                                ctx.stroke();
                            }
                        });
                    }
                    
                    // Add neurons for this tick
                    for (let i = 0; i < 12; i++) {
                        const pos = positions[i];
                        const act = activations[i];
                        const normalizedAct = maxAct > 0 ? Math.abs(act) / maxAct : 0;
                        
                        const selfSyncIdx = this.connectionPaths.findIndex(c => c.i === i && c.j === i);
                        const selfSync = selfSyncIdx >= 0 ? syncValues[selfSyncIdx] : 0;
                        
                        const isSelected = isCurrentTick && this.selectedNeuron === i;
                        const isHovered = isCurrentTick && this.hoveredNeuron === i;
                        
                        renderItems.push({
                            type: 'neuron',
                            depth: pos.depth,
                            tick,
                            draw: () => {
                                const radius = (isCurrentTick ? 22 : 16) + normalizedAct * (isCurrentTick ? 10 : 4);
                                const glowRadius = radius + 18 + Math.abs(selfSync) * 0.5;
                                
                                // Glow for self-sync (current tick only)
                                if (isCurrentTick && selfSync > 0) {
                                    const gradient = ctx.createRadialGradient(pos.x, pos.y, radius, pos.x, pos.y, glowRadius);
                                    gradient.addColorStop(0, `rgba(74, 158, 255, ${0.3 * layerAlpha})`);
                                    gradient.addColorStop(1, 'rgba(74, 158, 255, 0)');
                                    ctx.fillStyle = gradient;
                                    ctx.beginPath();
                                    ctx.arc(pos.x, pos.y, glowRadius, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                                
                                // Selection/hover ring (current tick only)
                                if (isSelected || isHovered) {
                                    ctx.strokeStyle = '#4a9eff';
                                    ctx.lineWidth = 3;
                                    ctx.beginPath();
                                    ctx.arc(pos.x, pos.y, radius + 6, 0, Math.PI * 2);
                                    ctx.stroke();
                                }
                                
                                // Neuron body
                                const brightness = 30 + normalizedAct * 40;
                                const hue = act >= 0 ? 210 : 340;
                                ctx.fillStyle = `hsla(${hue}, 60%, ${brightness}%, ${layerAlpha})`;
                                ctx.beginPath();
                                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                                ctx.fill();
                                
                                // Border
                                ctx.strokeStyle = `rgba(255,255,255,${0.3 * layerAlpha})`;
                                ctx.lineWidth = 1;
                                ctx.stroke();
                                
                                // Label (only on current tick or if neurons are big enough)
                                if (isCurrentTick || radius > 14) {
                                    ctx.fillStyle = `rgba(255,255,255,${layerAlpha})`;
                                    ctx.font = `${isCurrentTick ? 14 : 10}px SF Mono, Consolas, monospace`;
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'middle';
                                    ctx.fillText(i.toString(), pos.x, pos.y);
                                }
                            }
                        });
                    }
                    
                    // Add tick label for this layer
                    if (positions.length > 0) {
                        // Position label below each layer (find bottommost neuron)
                        const bottomNeuron = positions.reduce((best, p) => p.y > best.y ? p : best, positions[0]);
                        // Also get center X of this layer
                        const centerX = positions.reduce((sum, p) => sum + p.x, 0) / positions.length;
                        
                        renderItems.push({
                            type: 'label',
                            depth: layerDepth - 1000, // Draw labels behind
                            tick,
                            draw: () => {
                                const labelX = centerX;
                                const labelY = bottomNeuron.y + 35;
                                
                                ctx.font = `${isCurrentTick ? 'bold 14px' : '12px'} SF Mono, Consolas, monospace`;
                                ctx.fillStyle = isCurrentTick ? '#4a9eff' : `rgba(120, 140, 160, ${layerAlpha * 2})`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(`t${tick + 1}`, labelX, labelY);
                            }
                        });
                    }
                }
                
                // Sort by depth (back to front)
                renderItems.sort((a, b) => a.depth - b.depth);
                
                // Render all items
                for (const item of renderItems) {
                    item.draw();
                }
            }
        }

        // Initialize
        let visualizer;
        document.addEventListener('DOMContentLoaded', () => {
            visualizer = new CTMVisualizer();
            visualizer.init();
        });
    </script>
</body>
</html>
