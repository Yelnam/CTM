<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CTM Visualizer</title>
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Mobile Block Overlay */
        .mobile-block-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0e14 0%, #111820 100%);
            z-index: 9999;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            padding: 40px;
            text-align: center;
        }

        .mobile-block-overlay .mobile-icon {
            font-size: 64px;
            margin-bottom: 24px;
            opacity: 0.8;
        }

        .mobile-block-overlay h2 {
            font-size: 24px;
            font-weight: 600;
            color: #f0f4f8;
            margin-bottom: 16px;
        }

        .mobile-block-overlay p {
            font-size: 16px;
            color: #a0b0c0;
            line-height: 1.6;
            max-width: 320px;
        }

        .mobile-block-overlay .desktop-icon {
            margin-top: 32px;
            font-size: 48px;
            opacity: 0.6;
        }

        @media (max-width: 900px), (hover: none) and (pointer: coarse) {
            .mobile-block-overlay {
                display: flex;
            }
            body > *:not(.mobile-block-overlay) {
                display: none !important;
            }
        }

        :root {
            --bg-deep: #0a0e14;
            --bg-panel: #111820;
            --bg-hover: #1a2230;
            --text-primary: #f0f4f8;
            --text-secondary: #a0b0c0;
            --text-dim: #6a7a8a;
            --accent-blue: #4a9eff;
            --accent-cyan: #00d4aa;
            --accent-orange: #ff9f43;
            --accent-pink: #ff6b9d;
            --neuron-glow: #4a9eff;
            --connection-base: #2a3a4a;
        }

        body {
            background: var(--bg-deep);
            color: var(--text-primary);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .main-container {
            flex: 1;
            display: flex;
            padding: 20px;
            gap: 20px;
            min-height: 0;
        }

        /* Left Panel - Input & Attention */
        .left-panel {
            width: 280px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
            padding-right: 4px;
        }

        /* Subtle scrollbar for left panel */
        .left-panel::-webkit-scrollbar {
            width: 6px;
        }

        .left-panel::-webkit-scrollbar-track {
            background: transparent;
        }

        .left-panel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 3px;
        }

        .left-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        /* Confidence Section */
        .confidence-section {
            text-align: center;
        }

        .confidence-value {
            font-size: 28px;
            font-weight: 700;
            font-family: 'SF Mono', 'Consolas', monospace;
            background: linear-gradient(135deg, var(--accent-cyan) 0%, var(--accent-blue) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }

        .confidence-bar {
            height: 8px;
            background: var(--bg-deep);
            border-radius: 4px;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-blue));
            transition: width 0.3s ease;
        }

        .confidence-label {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .panel {
            background: var(--bg-panel);
            border-radius: 12px;
            padding: 20px;
        }

        .panel-row {
            display: flex;
            gap: 12px;
        }

        .panel-half {
            flex: 1;
            padding: 16px;
        }

        .panel-title {
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-secondary);
            margin-bottom: 16px;
        }

        .input-display {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-bottom: 16px;
        }

        .input-number {
            width: 56px;
            height: 56px;
            background: var(--bg-deep);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .input-number input {
            width: 100%;
            height: 100%;
            background: transparent;
            border: none;
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 24px;
            font-weight: 600;
            font-family: 'SF Mono', 'Consolas', monospace;
            text-align: center;
            outline: none;
        }

        .input-number input:focus {
            box-shadow: 0 0 0 2px var(--accent-blue);
        }

        .input-number .attn-bar {
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            height: 3px;
            background: var(--accent-cyan);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .run-button {
            height: 56px;
            padding: 0 24px;
            background: linear-gradient(135deg, var(--accent-cyan) 0%, var(--accent-blue) 100%);
            border: none;
            border-radius: 8px;
            color: #ffffff;
            font-size: 20px;
            font-weight: 700;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            cursor: pointer;
            transition: transform 0.1s ease, box-shadow 0.1s ease;
        }

        .run-button:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 20px rgba(74, 158, 255, 0.3);
        }

        .run-button:active {
            transform: scale(0.98);
        }

        .run-button:focus {
            outline: none;
            animation: focusGlow 2s ease-in-out infinite;
        }

        @keyframes focusGlow {
            0%, 100% { box-shadow: 0 0 15px rgba(0, 212, 170, 0.4), 0 0 30px rgba(74, 158, 255, 0.2); }
            50% { box-shadow: 0 0 25px rgba(0, 212, 170, 0.7), 0 0 50px rgba(74, 158, 255, 0.4); }
        }

        .run-button.running {
            animation: runPulse 150ms ease-in-out;
        }

        @keyframes runPulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        .run-button:disabled {
            cursor: not-allowed;
            opacity: 0.7;
            animation: none;
        }

        /* Prediction display in second panel */
        .prediction-display {
            display: flex;
            align-items: baseline;
            justify-content: center;
        }

        .prediction-value {
            font-size: 44px;
            font-weight: 700;
            font-family: 'SF Mono', 'Consolas', monospace;
            background: linear-gradient(135deg, var(--accent-cyan) 0%, var(--accent-blue) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Attention Panel - expanded */
        .attention-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .attention-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .attention-head {
            flex: 1;
        }

        .attention-head-label {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 10px;
            font-weight: 500;
        }

        .attention-rows {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .attention-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .attention-pos {
            font-size: 12px;
            font-family: 'SF Mono', 'Consolas', monospace;
            color: var(--text-dim);
            width: 24px;
        }

        .attention-input-val {
            font-size: 14px;
            font-family: 'SF Mono', 'Consolas', monospace;
            color: var(--text-primary);
            background: var(--bg-deep);
            padding: 4px 8px;
            border-radius: 4px;
            min-width: 28px;
            text-align: center;
        }

        .attention-bar-container {
            flex: 1;
            height: 24px;
            background: var(--bg-deep);
            border-radius: 4px;
            overflow: hidden;
        }

        .attention-bar-fill {
            height: 100%;
            background: var(--accent-cyan);
            transition: width 0.3s ease;
            opacity: 0.8;
        }

        .attention-weight {
            font-size: 13px;
            font-family: 'SF Mono', 'Consolas', monospace;
            color: var(--text-secondary);
            width: 36px;
            text-align: right;
        }

        /* Center Panel - Network */
        .center-panel {
            flex: 1;
            min-width: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        @media (max-width: 1200px) {
            .center-panel {
                min-width: 350px;
            }
        }

        @media (max-width: 1050px) {
            .center-panel {
                min-width: 300px;
            }
        }

        .network-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .network-title-box {
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-panel);
            border-radius: 8px;
            padding: 8px 16px;
            z-index: 10;
        }

        .network-title-box span {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #networkCanvas {
            width: 100%;
            height: 100%;
        }

        /* Confidence Chart at bottom center */
        .confidence-chart-container {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            background: var(--bg-panel);
            border-radius: 12px;
            padding: 12px 16px;
        }

        /* Right Panel - Detail View */
        .right-panel {
            width: 500px;
            min-width: 320px;
            display: flex;
            flex-direction: column;
            flex-shrink: 1;
            min-height: 0;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 1400px) {
            .right-panel {
                width: 400px;
            }
            .nlm-diagram-container {
                height: 450px !important;
            }
        }

        @media (max-width: 1200px) {
            .right-panel {
                width: 340px;
            }
            .left-panel {
                width: 240px;
            }
            .nlm-diagram-container {
                height: 380px !important;
            }
            .main-container {
                padding: 12px;
                gap: 12px;
            }
        }

        @media (max-width: 1050px) {
            .right-panel {
                width: 300px;
                min-width: 280px;
            }
            .left-panel {
                width: 220px;
            }
            .nlm-diagram-container {
                height: 320px !important;
            }
        }

        /* Detail Panel - full height with modern scrollbar */
        .detail-panel {
            flex: 1;
            background: var(--bg-deep);
            border-radius: 8px;
            padding: 16px;
            overflow-y: auto;
            min-height: 0;
        }
        
        /* The wrapper panel inside right-panel */
        .right-panel > .panel {
            min-height: 0;
        }

        /* Modern scrollbar styling */
        .detail-panel::-webkit-scrollbar {
            width: 8px;
        }

        .detail-panel::-webkit-scrollbar-track {
            background: var(--bg-deep);
            border-radius: 4px;
        }

        .detail-panel::-webkit-scrollbar-thumb {
            background: var(--text-dim);
            border-radius: 4px;
        }

        .detail-panel::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        /* Model Card */
        .model-card {
            background: var(--bg-panel);
            border-radius: 12px;
            padding: 16px 20px;
            margin-top: auto;
        }

        .model-card-content {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .detail-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--accent-cyan);
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .detail-title .neuron-label {
            flex-shrink: 0;
        }

        .detail-title .inline-output {
            display: flex;
            align-items: baseline;
            gap: 8px;
            margin-left: auto;
            margin-right: 12px;
        }

        .detail-title .inline-output .output-label-small {
            font-size: 12px;
            font-weight: 400;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .detail-title .inline-output .output-value-inline {
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 20px;
            font-weight: 600;
        }

        .detail-title .inline-output .output-value-inline.positive {
            color: var(--accent-cyan);
        }

        .detail-title .inline-output .output-value-inline.negative {
            color: var(--accent-pink);
        }

        @media (max-width: 1200px) {
            .detail-title .inline-output {
                margin-left: 0;
                margin-right: auto;
            }
        }

        .detail-close {
            margin-left: auto;
            cursor: pointer;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .detail-close:hover {
            opacity: 1;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid var(--bg-panel);
            font-size: 14px;
        }

        .detail-row:last-child {
            border-bottom: none;
        }

        .detail-label {
            color: var(--text-dim);
        }

        .detail-value {
            font-family: 'SF Mono', 'Consolas', monospace;
            color: var(--text-primary);
        }

        .matrix-display {
            margin-top: 12px;
            background: var(--bg-panel);
            border-radius: 6px;
            padding: 10px;
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 11px;
            overflow-x: auto;
        }

        .matrix-row {
            display: flex;
            gap: 4px;
        }

        .matrix-cell {
            min-width: 40px;
            text-align: right;
            padding: 2px 4px;
            border-radius: 2px;
        }

        .matrix-cell.positive {
            background: rgba(0, 212, 170, 0.2);
            color: var(--accent-cyan);
        }

        .matrix-cell.negative {
            background: rgba(255, 107, 157, 0.2);
            color: var(--accent-pink);
        }

        /* NLM Diagram Styles */
        .nlm-diagram-container {
            width: 100%;
            height: 555px;
            background: var(--bg-panel);
            border-radius: 8px;
            margin: 16px 0;
        }

        .nlm-diagram-container canvas {
            width: 100%;
            height: 100%;
        }

        .nlm-legend {
            display: flex;
            justify-content: center;
            gap: 24px;
            padding: 12px 0;
            border-top: 1px solid var(--bg-hover);
            margin-top: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 17px;
            color: var(--text-secondary);
        }

        .legend-color {
            width: 18px;
            height: 18px;
            border-radius: 50%;
        }

        .legend-color.positive {
            background: var(--accent-cyan);
            box-shadow: 0 0 6px var(--accent-cyan);
        }

        .legend-color.negative {
            background: var(--accent-pink);
            box-shadow: 0 0 6px var(--accent-pink);
        }

        .nlm-output-summary {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: var(--bg-panel);
            border-radius: 8px;
            margin-top: 16px;
        }

        .output-label {
            font-size: 24px;
            color: var(--text-secondary);
        }

        .output-value {
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 36px;
            font-weight: 600;
        }

        .output-value.positive {
            color: var(--accent-cyan);
        }

        .output-value.negative {
            color: var(--accent-pink);
        }

        /* Contribution Chart */
        .contribution-chart-section {
            margin-top: 20px;
            border-top: 1px solid var(--bg-hover);
            padding-top: 16px;
        }

        .contribution-chart-title {
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-secondary);
            margin-bottom: 16px;
        }

        .contribution-chart-container {
            max-height: 380px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 10px;
        }

        /* Modern minimal scrollbar */
        .contribution-chart-container::-webkit-scrollbar {
            width: 6px;
        }

        .contribution-chart-container::-webkit-scrollbar-track {
            background: transparent;
        }

        .contribution-chart-container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 3px;
        }

        .contribution-chart-container::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        .contrib-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        .contrib-row:hover {
            background: rgba(74, 158, 255, 0.1);
        }

        .contrib-row.selected {
            background: rgba(74, 158, 255, 0.25);
            box-shadow: inset 0 0 0 1px rgba(74, 158, 255, 0.5);
        }

        .contrib-pair {
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 14px;
            color: var(--text-secondary);
            width: 54px;
            flex-shrink: 0;
        }

        .contrib-bar-container {
            flex: 1;
            height: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            overflow: hidden;
        }

        .contrib-bar {
            height: 100%;
            border-radius: 4px;
            transition: width 0.2s ease;
        }

        .contrib-bar.positive {
            background: linear-gradient(90deg, rgba(0, 212, 170, 0.6), rgba(0, 212, 170, 0.9));
        }

        .contrib-bar.negative {
            background: linear-gradient(90deg, rgba(255, 107, 157, 0.6), rgba(255, 107, 157, 0.9));
        }

        .contrib-value {
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 14px;
            width: 62px;
            text-align: right;
            flex-shrink: 0;
        }

        .contrib-value.positive {
            color: var(--accent-cyan);
        }

        .contrib-value.negative {
            color: var(--accent-pink);
        }

        /* Explanation Overlay */
        .explanation-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .explanation-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .explanation-content {
            width: 66%;
            height: 66%;
            background: rgba(20, 30, 40, 0.6);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(74, 158, 255, 0.2);
            border-radius: 16px;
            padding: 40px;
            display: flex;
            flex-direction: column;
            position: relative;
            box-shadow: 0 0 60px rgba(0, 0, 0, 0.3);
        }

        .explanation-content.speech-bubble {
            width: 66%;
            height: 66%;
        }

        .explanation-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: transparent;
            border: 1px solid var(--text-dim);
            border-radius: 8px;
            color: var(--text-secondary);
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .explanation-close:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .explanation-title {
            font-size: 28px;
            font-weight: 600;
            color: var(--accent-cyan);
            margin-bottom: 32px;
            text-align: center;
        }

        .explanation-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            gap: 32px;
        }

        .explanation-section {
            max-width: 900px;
        }

        .explanation-section h3 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }

        .explanation-section p {
            font-size: 18px;
            line-height: 1.7;
            color: var(--text-primary);
        }

        .explanation-math {
            background: rgba(74, 158, 255, 0.08);
            border: 1px solid rgba(74, 158, 255, 0.2);
            border-radius: 8px;
            padding: 16px 24px;
            margin-top: 16px;
            display: inline-block;
        }

        .explanation-math .katex {
            font-size: 1.3em;
            color: var(--accent-cyan);
        }

        .explanation-math-label {
            font-size: 12px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
            display: block;
        }

        /* Responsive explanation text for smaller screens */
        @media (max-width: 1400px) {
            .explanation-content {
                width: 75%;
                height: 75%;
                padding: 32px;
            }
            .explanation-title {
                font-size: 24px;
                margin-bottom: 24px;
            }
            .explanation-body {
                gap: 24px;
            }
            .explanation-section p {
                font-size: 16px;
                line-height: 1.6;
            }
            .explanation-section h3 {
                font-size: 13px;
                margin-bottom: 10px;
            }
        }

        @media (max-width: 1100px) {
            .explanation-content {
                width: 85%;
                height: 80%;
                padding: 24px;
            }
            .explanation-title {
                font-size: 20px;
                margin-bottom: 20px;
            }
            .explanation-body {
                gap: 18px;
                overflow-y: auto;
            }
            
            /* Sleek scrollbar for explanation body */
            .explanation-body::-webkit-scrollbar {
                width: 6px;
            }
            .explanation-body::-webkit-scrollbar-track {
                background: transparent;
            }
            .explanation-body::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.15);
                border-radius: 3px;
            }
            .explanation-body::-webkit-scrollbar-thumb:hover {
                background: rgba(255, 255, 255, 0.25);
            }
            .explanation-section {
                max-width: 100%;
            }
            .explanation-section p {
                font-size: 14px;
                line-height: 1.55;
            }
            .explanation-section h3 {
                font-size: 12px;
                margin-bottom: 8px;
            }
            .explanation-close {
                width: 32px;
                height: 32px;
                font-size: 20px;
                top: 16px;
                right: 16px;
            }
        }

        /* Make panels clickable */
        .panel.clickable, 
        .model-card.clickable,
        .network-title-box.clickable, 
        .confidence-chart-container.clickable {
            cursor: pointer;
            transition: box-shadow 0.2s ease, border-color 0.2s ease;
            border: 1px solid transparent;
        }

        .panel.clickable:hover, 
        .model-card.clickable:hover,
        .network-title-box.clickable:hover, 
        .confidence-chart-container.clickable:hover {
            border-color: rgba(74, 158, 255, 0.3);
            box-shadow: 0 0 20px rgba(74, 158, 255, 0.1);
        }

        /* Control Dock */
        .control-dock {
            background: var(--bg-panel);
            padding: 16px 24px;
            display: flex;
            justify-content: center;
            gap: 32px;
            border-top: 1px solid var(--bg-hover);
            position: relative;
            z-index: 100;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-key {
            min-width: 36px;
            height: 36px;
            background: var(--bg-deep);
            border: 1px solid var(--text-dim);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-family: 'SF Mono', 'Consolas', monospace;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .control-key:hover {
            border-color: var(--accent-blue);
            color: var(--accent-blue);
        }

        .control-key.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: var(--bg-deep);
        }

        .control-label {
            font-size: 16px;
            color: var(--text-secondary);
        }

        .preset-keys {
            display: flex;
            gap: 4px;
        }

        .preset-key {
            width: 32px;
            height: 32px;
            font-size: 13px;
        }

        /* Hidden state */
        .hidden {
            display: none !important;
        }

        /* Loading */
        .loading {
            position: fixed;
            inset: 0;
            background: var(--bg-deep);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-text {
            font-size: 18px;
            color: var(--text-secondary);
        }
</style>
</head>
<body>
    <!-- Mobile Block Overlay -->
    <div class="mobile-block-overlay">
        <div class="mobile-icon">üì±</div>
        <h2>Desktop Required</h2>
        <p>This interactive CTM visualizer requires a larger screen for the full experience. Please open this link on a desktop or laptop computer.</p>
        <div class="desktop-icon">üñ•Ô∏è</div>
    </div>

    <div class="loading" id="loading">
        <div class="loading-text">Loading CTM...</div>
    </div>

    <div class="main-container">
        <!-- Left Panel -->
        <div class="left-panel">
            <div class="panel clickable" data-explain="input">
                <div class="panel-title">Input</div>
                <div class="input-display">
                    <div class="input-number">
                        <input type="text" id="input0" tabindex="1" maxlength="2" value="2">
                        <div class="attn-bar" style="width: 0%"></div>
                    </div>
                    <div class="input-number">
                        <input type="text" id="input1" tabindex="2" maxlength="2" value="4">
                        <div class="attn-bar" style="width: 0%"></div>
                    </div>
                    <div class="input-number">
                        <input type="text" id="input2" tabindex="3" maxlength="2" value="6">
                        <div class="attn-bar" style="width: 0%"></div>
                    </div>
                    <button id="runButton" tabindex="4" class="run-button">Run</button>
                </div>
            </div>

            <div class="panel-row" id="predConfRow">
                <div class="panel panel-half clickable" data-explain="prediction" id="predictionPanel">
                    <div class="panel-title" id="predictionTitle">Prediction</div>
                    <div class="prediction-display">
                        <span class="prediction-value" id="predictionBox">-</span>
                    </div>
                </div>
                <div class="panel panel-half clickable" data-explain="confidence">
                    <div class="panel-title">Confidence</div>
                    <div class="confidence-section">
                        <div class="confidence-value" id="confidenceText">-</div>
                        <div class="confidence-bar">
                            <div class="confidence-fill" id="confidenceFill" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel attention-panel clickable" data-explain="attention">
                <div class="panel-title">Attention</div>
                <div class="attention-section">
                    <div class="attention-head">
                        <div class="attention-head-label">Head 0</div>
                        <div class="attention-rows" id="attnHead0">
                            <div class="attention-row">
                                <span class="attention-pos">P0</span>
                                <span class="attention-input-val" data-pos="0">2</span>
                                <div class="attention-bar-container">
                                    <div class="attention-bar-fill" style="width: 33%"></div>
                                </div>
                                <span class="attention-weight">0.33</span>
                            </div>
                            <div class="attention-row">
                                <span class="attention-pos">P1</span>
                                <span class="attention-input-val" data-pos="1">4</span>
                                <div class="attention-bar-container">
                                    <div class="attention-bar-fill" style="width: 33%"></div>
                                </div>
                                <span class="attention-weight">0.33</span>
                            </div>
                            <div class="attention-row">
                                <span class="attention-pos">P2</span>
                                <span class="attention-input-val" data-pos="2">6</span>
                                <div class="attention-bar-container">
                                    <div class="attention-bar-fill" style="width: 33%"></div>
                                </div>
                                <span class="attention-weight">0.33</span>
                            </div>
                        </div>
                    </div>
                    <div class="attention-head">
                        <div class="attention-head-label">Head 1</div>
                        <div class="attention-rows" id="attnHead1">
                            <div class="attention-row">
                                <span class="attention-pos">P0</span>
                                <span class="attention-input-val" data-pos="0">2</span>
                                <div class="attention-bar-container">
                                    <div class="attention-bar-fill" style="width: 33%"></div>
                                </div>
                                <span class="attention-weight">0.33</span>
                            </div>
                            <div class="attention-row">
                                <span class="attention-pos">P1</span>
                                <span class="attention-input-val" data-pos="1">4</span>
                                <div class="attention-bar-container">
                                    <div class="attention-bar-fill" style="width: 33%"></div>
                                </div>
                                <span class="attention-weight">0.33</span>
                            </div>
                            <div class="attention-row">
                                <span class="attention-pos">P2</span>
                                <span class="attention-input-val" data-pos="2">6</span>
                                <div class="attention-bar-container">
                                    <div class="attention-bar-fill" style="width: 33%"></div>
                                </div>
                                <span class="attention-weight">0.33</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="model-card clickable" data-explain="model">
                <div class="panel-title">Model</div>
                <div class="model-card-content">
                    7,999 parameters ¬∑ 12 neurons ¬∑ 78 sync pairs ¬∑ 6 ticks
                </div>
            </div>
        </div>

        <!-- Center Panel -->
        <div class="center-panel">
            <div class="network-title-box clickable" data-explain="network">
                <span>Continuous Thought Machine</span>
            </div>
            <div class="network-container">
                <canvas id="networkCanvas"></canvas>
            </div>
            <div class="confidence-chart-container clickable" data-explain="ticks">
                <div class="panel-title" style="text-align: center; margin-bottom: 8px;">Confidence Over Ticks</div>
                <canvas id="confidenceChart" height="80"></canvas>
            </div>
        </div>

        <!-- Right Panel - Detail View -->
        <div class="right-panel">
            <div class="panel clickable" data-explain="detail" style="flex: 1; display: flex; flex-direction: column;">
                <div class="panel-title">Detail View</div>
                <div class="detail-panel" id="detailPanel">
                    <div style="color: var(--text-secondary); font-size: 16px;">
                        Click a neuron or connection to inspect
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Control Dock -->
    <div class="control-dock">
        <div class="control-group">
            <div class="control-key" id="keyLeft">‚Æú¬ê</div>
            <div class="control-key" id="keyRight">‚Æû</div>
            <div class="control-label">Step through ticks</div>
        </div>

        <div class="control-group">
            <div class="control-key" id="keySpace" style="min-width: 64px;">Space</div>
            <div class="control-label">Play / Pause</div>
        </div>

        <div class="control-group">
            <div class="control-key" id="keyNew">N</div>
            <div class="control-label">New manual seq.</div>
        </div>

        <div class="control-group">
            <div class="preset-keys">
                <div class="control-key preset-key" data-preset="1">1</div>
                <div class="control-key preset-key" data-preset="2">2</div>
                <div class="control-key preset-key" data-preset="3">3</div>
                <div class="control-key preset-key" data-preset="4">4</div>
                <div class="control-key preset-key" data-preset="5">5</div>
            </div>
            <div class="control-label">Run random seq. (intvl 1-5)</div>
        </div>

        <div class="control-group">
            <div class="control-key" id="keyPredict">P</div>
            <div class="control-label">Jump to prediction</div>
        </div>
    </div>

    <!-- Explanation Overlay -->
    <div class="explanation-overlay" id="explanationOverlay">
        <div class="explanation-content">
            <button class="explanation-close" id="explanationClose">√ó</button>
            <div class="explanation-title" id="explanationTitle"></div>
            <div class="explanation-body" id="explanationBody"></div>
        </div>
    </div>

    <script>
        // ============================================================
        // CTM Inference Engine (embedded)
        // ============================================================
        
        class CTMInference {
            constructor(modelData) {
                this.config = modelData.config;
                this.weights = modelData.weights;
                this.syncIndices = this.computeSyncIndices();
            }

            computeSyncIndices() {
                const d = this.config.d_model;
                const indices = [];
                for (let i = 0; i < d; i++) {
                    for (let j = i; j < d; j++) {
                        indices.push([i, j]);
                    }
                }
                return indices;
            }

            zeros(shape) {
                if (shape.length === 1) return new Array(shape[0]).fill(0);
                if (shape.length === 2) return Array.from({ length: shape[0] }, () => new Array(shape[1]).fill(0));
                return Array.from({ length: shape[0] }, () => this.zeros(shape.slice(1)));
            }

            clone(arr) { return JSON.parse(JSON.stringify(arr)); }
            add(a, b) { return typeof a === 'number' ? a + b : a.map((v, i) => this.add(v, b[i])); }
            dot(a, b) { return a.reduce((sum, v, i) => sum + v * b[i], 0); }
            matvec(A, x) { return A.map(row => this.dot(row, x)); }
            softmax(x) {
                const max = Math.max(...x);
                const exp = x.map(v => Math.exp(v - max));
                const sum = exp.reduce((a, b) => a + b, 0);
                return exp.map(v => v / sum);
            }
            softplus(x) { return typeof x === 'number' ? Math.log(1 + Math.exp(x)) : x.map(v => Math.log(1 + Math.exp(v))); }
            relu(x) { return typeof x === 'number' ? Math.max(0, x) : x.map(v => this.relu(v)); }
            concat(a, b) { return [...a, ...b]; }

            linear(x, weight, bias) {
                const out = this.matvec(weight, x);
                return this.add(out, bias);
            }

            layerNorm(x, weight, bias, eps = 1e-5) {
                const mean = x.reduce((a, b) => a + b, 0) / x.length;
                const variance = x.reduce((a, b) => a + (b - mean) ** 2, 0) / x.length;
                const std = Math.sqrt(variance + eps);
                return x.map((v, i) => ((v - mean) / std) * weight[i] + bias[i]);
            }

            embedding(indices, table) { return indices.map(i => [...table[i]]); }

            computeSync(postActHistory) {
                const T = postActHistory.length;
                const decayRates = this.softplus(this.weights.decay);
                
                const timeWeights = [];
                for (let t = 0; t < T; t++) {
                    const tBack = T - 1 - t;
                    timeWeights.push(decayRates.map(d => Math.exp(-d * tBack)));
                }
                
                const sync = new Array(this.config.d_sync).fill(0);
                for (let s = 0; s < this.syncIndices.length; s++) {
                    const [i, j] = this.syncIndices[s];
                    let weightedSum = 0, weightSum = 0;
                    for (let t = 0; t < T; t++) {
                        const product = postActHistory[t][i] * postActHistory[t][j];
                        const w = timeWeights[t][s];
                        weightedSum += product * w;
                        weightSum += w;
                    }
                    sync[s] = weightedSum / (weightSum + 1e-8);
                }
                return sync;
            }

            nlmForward(preActHistory) {
                const { d_model, memory_length, nlm_hidden } = this.config;
                const output = [];
                
                for (let neuron = 0; neuron < d_model; neuron++) {
                    const history = preActHistory[neuron];
                    const hidden = new Array(nlm_hidden).fill(0);
                    
                    for (let hi = 0; hi < nlm_hidden; hi++) {
                        let sum = this.weights.nlm_b1[neuron][hi];
                        for (let mi = 0; mi < memory_length; mi++) {
                            sum += history[mi] * this.weights.nlm_w1[neuron][mi][hi];
                        }
                        hidden[hi] = Math.max(0, sum);
                    }
                    
                    let out = this.weights.nlm_b2[neuron][0];
                    for (let hi = 0; hi < nlm_hidden; hi++) {
                        out += hidden[hi] * this.weights.nlm_w2[neuron][hi][0];
                    }
                    output.push(out);
                }
                return output;
            }

            synapse(z, attnOut) {
                const input = this.concat(z, attnOut);
                let h = this.linear(input, this.weights.synapse_0_weight, this.weights.synapse_0_bias);
                h = this.layerNorm(h, this.weights.synapse_1_weight, this.weights.synapse_1_bias);
                h = this.relu(h);
                h = this.linear(h, this.weights.synapse_3_weight, this.weights.synapse_3_bias);
                return h;
            }

            forward(numbers, returnInternals = false) {
                const { seq_length, d_model, n_heads, head_dim, memory_length, n_ticks } = this.config;
                
                const numEmb = this.embedding(numbers, this.weights.num_embed);
                const posEmb = this.embedding([0, 1, 2].slice(0, seq_length), this.weights.pos_embed);
                const embeddings = numEmb.map((ne, i) => this.add(ne, posEmb[i]));
                
                const kvFeatures = embeddings.map(emb => 
                    this.linear(emb, this.weights.kv_proj_weight, this.weights.kv_proj_bias)
                );
                
                const K = [], V = [];
                for (let h = 0; h < n_heads; h++) {
                    const kHead = [], vHead = [];
                    for (let s = 0; s < seq_length; s++) {
                        const headStart = h * head_dim * 2;
                        kHead.push(kvFeatures[s].slice(headStart, headStart + head_dim));
                        vHead.push(kvFeatures[s].slice(headStart + head_dim, headStart + head_dim * 2));
                    }
                    K.push(kHead);
                    V.push(vHead);
                }
                
                let z = this.clone(this.weights.z_init);
                let preActHistory = this.clone(this.weights.pre_act_history_init);
                const postActHistory = [this.clone(z)];
                const outputs = [];
                
                const internals = returnInternals ? {
                    postActivations: [],
                    sync: [],
                    attentionWeights: [],
                    preActHistory: [],
                    predictions: [],
                    confidences: []
                } : null;
                
                for (let t = 0; t < n_ticks; t++) {
                    const sync = this.computeSync(postActHistory);
                    const qFlat = this.linear(sync, this.weights.q_proj_weight, this.weights.q_proj_bias);
                    
                    const Q = [];
                    for (let h = 0; h < n_heads; h++) {
                        Q.push([qFlat.slice(h * head_dim, (h + 1) * head_dim)]);
                    }
                    
                    const attnWeightsAllHeads = [];
                    const attnOutPerHead = [];
                    
                    for (let h = 0; h < n_heads; h++) {
                        const scores = [];
                        for (let s = 0; s < seq_length; s++) {
                            scores.push(this.dot(Q[h][0], K[h][s]) / Math.sqrt(head_dim));
                        }
                        const attnWeights = this.softmax(scores);
                        attnWeightsAllHeads.push(attnWeights);
                        
                        const attnOut = new Array(head_dim).fill(0);
                        for (let s = 0; s < seq_length; s++) {
                            for (let d = 0; d < head_dim; d++) {
                                attnOut[d] += attnWeights[s] * V[h][s][d];
                            }
                        }
                        attnOutPerHead.push(attnOut);
                    }
                    
                    const attnConcat = attnOutPerHead.flat();
                    const attnOut = this.linear(attnConcat, this.weights.attn_out_proj_weight, this.weights.attn_out_proj_bias);
                    const preAct = this.synapse(z, attnOut);
                    
                    for (let n = 0; n < d_model; n++) {
                        for (let m = 0; m < memory_length - 1; m++) {
                            preActHistory[n][m] = preActHistory[n][m + 1];
                        }
                        preActHistory[n][memory_length - 1] = preAct[n];
                    }
                    
                    z = this.nlmForward(preActHistory);
                    postActHistory.push(this.clone(z));
                    
                    const finalSync = this.computeSync(postActHistory);
                    const logits = this.linear(finalSync, this.weights.output_proj_weight, this.weights.output_proj_bias);
                    outputs.push(logits);
                    
                    if (internals) {
                        internals.postActivations.push(this.clone(z));
                        internals.sync.push(this.clone(finalSync));
                        internals.attentionWeights.push(this.clone(attnWeightsAllHeads));
                        internals.preActHistory.push(this.clone(preActHistory));
                        
                        const probs = this.softmax(logits);
                        const predIdx = logits.indexOf(Math.max(...logits));
                        internals.predictions.push(predIdx + 1);
                        internals.confidences.push(probs[predIdx]);
                    }
                }
                
                const finalLogits = outputs[outputs.length - 1];
                const probs = this.softmax(finalLogits);
                const predIdx = finalLogits.indexOf(Math.max(...finalLogits));
                
                return { outputs, prediction: predIdx + 1, confidence: probs[predIdx], internals };
            }

            getSyncPairInfo(pairIndex) {
                const [i, j] = this.syncIndices[pairIndex];
                const decay = this.softplus([this.weights.decay[pairIndex]])[0];
                return { neuronI: i, neuronJ: j, decayRate: decay, isSelf: i === j };
            }

            getNeuronNLMWeights(neuronIndex) {
                return {
                    w1: this.weights.nlm_w1[neuronIndex],
                    b1: this.weights.nlm_b1[neuronIndex],
                    w2: this.weights.nlm_w2[neuronIndex],
                    b2: this.weights.nlm_b2[neuronIndex]
                };
            }
        }

        // ============================================================
        // Visualizer Application
        // ============================================================
        
        class CTMVisualizer {
            constructor() {
                this.ctm = null;
                this.currentInput = [2, 4, 6];
                this.currentTick = 0;
                this.maxTicks = 6;
                this.ticksRevealed = 1;  // How many tick layers are visible (1 = just first ring, dormant)
                this.newestTickAlpha = 1.0;  // For fade-in effect
                this.inferenceResult = null;
                this.isPlaying = false;
                this.isRunning = false;
                this.playInterval = null;
                this.selectedNeuron = null;
                this.selectedConnection = null;
                this.hoveredNeuron = null;
                this.hoveredConnection = null;
                
                // Scale factor for neuron sizes - 1.0 at 1920px width (24" 1080p monitor)
                this.neuronScale = Math.min(1, window.innerWidth / 1920);
                
                this.presets = {
                    1: [1, 2, 3],
                    2: [2, 4, 6],
                    3: [3, 6, 9],
                    4: [4, 8, 12],
                    5: [5, 10, 15]
                };
                
                this.canvas = document.getElementById('networkCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.neuronPositions = [];
                this.connectionPaths = [];
            }
            
            generateRandomSequence(step) {
                // Generate a random starting point such that all 4 values stay within 1-50
                const maxStart = 50 - (3 * step);
                const start = Math.floor(Math.random() * maxStart) + 1;
                return [start, start + step, start + 2 * step];
            }

            async init() {
                try {
                    const response = await fetch('model_weights.json');
                    const modelData = await response.json();
                    this.ctm = new CTMInference(modelData);
                    
                    this.setupCanvas();
                    this.setupEventListeners();
                    // Don't run inference on load - wait for user to click Run
                    this.render();
                    
                    document.getElementById('loading').classList.add('hidden');
                    
                    // Focus the Run button so user can just press Enter
                    document.getElementById('runButton').focus();
                } catch (error) {
                    console.error('Failed to load model:', error);
                    document.getElementById('loading').innerHTML = 
                        '<div class="loading-text">Failed to load model. Ensure model_weights.json is in the same directory.</div>';
                }
            }

            setupCanvas() {
                const container = this.canvas.parentElement;
                const dpr = window.devicePixelRatio || 1;
                
                const resize = () => {
                    const rect = container.getBoundingClientRect();
                    this.canvas.width = rect.width * dpr;
                    this.canvas.height = rect.height * dpr;
                    this.canvas.style.width = rect.width + 'px';
                    this.canvas.style.height = rect.height + 'px';
                    this.ctx.scale(dpr, dpr);
                    this.canvasWidth = rect.width;
                    this.canvasHeight = rect.height;
                    
                    // Update neuron scale based on viewport width
                    this.neuronScale = Math.min(1, window.innerWidth / 1920);
                    
                    this.calculatePositions();
                    this.render();
                };
                
                resize();
                window.addEventListener('resize', resize);
            }

            calculatePositions() {
                // 3D parameters - horizontal cylinder (time flows left to right)
                this.rotationX = -15;  // Slight tilt down to see depth
                this.rotationY = 50;   // Start at max clockwise rotation
                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                
                // Cylinder dimensions
                const cx = this.canvasWidth / 2;
                const cy = this.canvasHeight / 2 - 90;  // Shifted up to balance space above/below
                this.centerX = cx;
                this.centerY = cy;
                this.circleRadius = Math.min(cx * 0.42, cy - 60) * 0.95;  // Radius of neuron circle
                this.layerSpacing = 60;  // Horizontal spacing between tick layers
                
                // Build connection paths (same for all ticks)
                this.connectionPaths = [];
                for (let i = 0; i < 12; i++) {
                    for (let j = i; j < 12; j++) {
                        this.connectionPaths.push({
                            i, j,
                            isSelf: i === j,
                            syncIndex: this.connectionPaths.length
                        });
                    }
                }
                
                this.updateProjectedPositions();
            }
            
            updateProjectedPositions() {
                // Convert rotation to radians
                const radX = this.rotationX * Math.PI / 180;
                const radY = this.rotationY * Math.PI / 180;
                
                // Precompute trig
                const cosX = Math.cos(radX);
                const sinX = Math.sin(radX);
                const cosY = Math.cos(radY);
                const sinY = Math.sin(radY);
                
                // Calculate 3D positions for all neurons on all ticks
                // neuronPositions3D[tick][neuronIdx] = {x, y, z, screenX, screenY}
                this.neuronPositions3D = [];
                
                for (let tick = 0; tick < this.maxTicks; tick++) {
                    const tickPositions = [];
                    // X position: tick 0 at left, tick 5 at right
                    // Center the cylinder horizontally
                    const xBase = (tick - (this.maxTicks - 1) / 2) * this.layerSpacing;
                    
                    for (let i = 0; i < 12; i++) {
                        const angle = (i / 12) * Math.PI * 2 - Math.PI / 2;
                        
                        // 3D position (before rotation)
                        // Circle is in Y-Z plane, time progresses along X
                        let x = xBase;
                        let y = Math.cos(angle) * this.circleRadius;
                        let z = Math.sin(angle) * this.circleRadius;
                        
                        // Apply Y rotation (spin around vertical axis)
                        const x1 = x * cosY - z * sinY;
                        const z1 = x * sinY + z * cosY;
                        x = x1;
                        z = z1;
                        
                        // Apply X rotation (tilt forward/back)
                        const y1 = y * cosX - z * sinX;
                        const z2 = y * sinX + z * cosX;
                        y = y1;
                        z = z2;
                        
                        // Project to screen (simple orthographic with slight perspective)
                        const scale = 1 + z * 0.001;  // Subtle perspective
                        const screenX = this.centerX + x * scale;
                        const screenY = this.centerY + y * scale;
                        
                        tickPositions.push({
                            x3d: x, y3d: y, z3d: z,
                            x: screenX,
                            y: screenY,
                            depth: z,  // For sorting
                            angle
                        });
                    }
                    this.neuronPositions3D.push(tickPositions);
                }
                
                // For backwards compatibility, keep neuronPositions as current tick
                this.neuronPositions = this.neuronPositions3D[this.currentTick] || this.neuronPositions3D[0];
            }

            setupEventListeners() {
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                this.canvas.addEventListener('mouseleave', () => {
                    this.hoveredNeuron = null;
                    this.hoveredConnection = null;
                    this.isDragging = false;
                    this.render();
                });
                
                // Drag rotation
                this.canvas.addEventListener('mousedown', (e) => {
                    // Only start drag if not over a neuron/connection
                    if (this.hoveredNeuron === null && this.hoveredConnection === null) {
                        this.isDragging = true;
                        this.lastMouseX = e.clientX;
                        this.lastMouseY = e.clientY;
                        this.canvas.style.cursor = 'grabbing';
                    }
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    this.canvas.style.cursor = 'default';
                });
                
                // Scroll wheel to step through ticks (throttled)
                this.lastWheelTime = 0;
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    
                    const now = Date.now();
                    if (now - this.lastWheelTime <75) return; // Throttle to (x)ms
                    this.lastWheelTime = now;
                    
                    if (e.deltaY > 0) {
                        // Scroll down = pull time toward viewer = higher tick
                        this.stepTick(1);
                    } else if (e.deltaY < 0) {
                        // Scroll up = push time away = lower tick
                        this.stepTick(-1);
                    }
                }, { passive: false });
                
                document.querySelectorAll('.preset-key').forEach(key => {
                    key.addEventListener('click', () => {
                        const preset = parseInt(key.dataset.preset);
                        this.loadPreset(preset);
                    });
                });
                
                document.getElementById('keyLeft').addEventListener('click', () => this.stepTick(-1));
                document.getElementById('keyRight').addEventListener('click', () => this.stepTick(1));
                document.getElementById('keySpace').addEventListener('click', () => this.togglePlay());
                document.getElementById('keyPredict').addEventListener('click', () => this.jumpToPrediction());
                document.getElementById('keyNew').addEventListener('click', () => this.startNewSequence());
                
                // Input field listeners - no live inference, Enter focuses Run button
                for (let i = 0; i < 3; i++) {
                    const input = document.getElementById(`input${i}`);
                    // Remove change listener that triggers inference
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            document.getElementById('runButton').focus();
                        }
                    });
                }
                
                // Run button handler
                const runButton = document.getElementById('runButton');
                runButton.addEventListener('click', () => this.executeRun());
                runButton.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.executeRun();
                    }
                });
                
                // Explanation overlay system
                this.setupExplanations();
            }

            setupExplanations() {
                const explanations = {
                    input: {
                        title: 'Input Sequence',
                        what: 'The first three numbers of a simple arithmetic sequence. The model has been trained to predict the fourth number, with constraints: values must lie between 1 and 50, incrementing in regular steps of 1 to 5. This tiny model has essentially memorized the training sequences‚Äîit doesn\'t truly generalize. Larger CTMs can learn underlying rules, but ours will fail on patterns it hasn\'t seen.',
                        interaction: 'Enter a valid sequence (like [1, 3, 5] or [36, 40, 44]), then click Run. Press N to clear and enter a new sequence. Press keys 1‚Äì5 to generate a random sequence with that step size. Try patterns outside the training range to see the model struggle!'
                    },
                    prediction: {
                        title: 'Prediction',
                        what: 'The model\'s predicted next value in the sequence. At each tick, the synchronization values‚Äîcorrelations between neuron pairs‚Äîare multiplied by learned weights and summed to produce this output. The prediction recalculates at each tick as the internal state evolves.',
                        interaction: 'Step through ticks with arrow keys to watch the prediction change. Early ticks often show rough estimates; later ticks usually settle on an answer (though not always‚Äîthe model can sometimes "overthink" and waver).',
                        math: 'y^t = W_{out} \\cdot S^t',
                        mathLabel: 'Output from synchronization'
                    },
                    confidence: {
                        title: 'Confidence',
                        what: 'How certain the model is about its prediction, shown as a percentage. This comes from the model\'s output layer: when it strongly favors one answer over alternatives, confidence is high. Low confidence means the model is torn between possibilities.',
                        interaction: 'Watch confidence build across ticks‚Äîthe model typically grows more certain as it "thinks" longer. After running, the display jumps to the tick where confidence peaked.'
                    },
                    attention: {
                        title: 'Attention Weights',
                        what: 'At each tick, the model decides how much to focus on each of the three input numbers. These bars show that focus. Having two "heads" lets the model look at the inputs in two different ways simultaneously‚Äîin larger models, one head might learn to compare adjacent numbers while another tracks position. (In a model this small, such clear specialization is unlikely to emerge‚Äîbut the mechanism is the same.)',
                        interaction: 'Compare how Head 0 and Head 1 distribute their attention differently. Notice how attention can shift across ticks as the model builds its understanding.',
                        math: '\\alpha_i = \\text{softmax}(q \\cdot k_i)',
                        mathLabel: 'Attention weight for position i'
                    },
                    model: {
                        title: 'Model Architecture',
                        what: 'This is a Continuous Thought Machine (CTM), a new type of neural network from Sakana AI (2025). Unlike standard networks that compute an answer in one pass, CTMs "think" through multiple steps called ticks. Two key innovations make this work: (1) each neuron contains its own tiny internal network with private learned weights, and (2) the model\'s internal representation is based on synchronization‚Äîhow pairs of neurons correlate over time‚Äîrather than just individual neuron values.',
                        interaction: 'Click any neuron to see its internal network. Step through ticks to watch thinking unfold. The 78 sync pairs capture all pairwise correlations between the 12 neurons.',
                        math: 'S^t_{ij} = \\sum_{\\tau=1}^{t} z^\\tau_i \\cdot z^\\tau_j \\cdot e^{-r_{ij}(t-\\tau)}',
                        mathLabel: 'Synchronization between neurons i and j'
                    },
                    network: {
                        title: '3D Network Visualization',
                        what: 'The cylinder shows computation unfolding through time‚Äîeach ring is one "tick" of processing (6 total). The 12 neurons are arranged in a circle at each tick. (There\'s nothing inherently circular about CTMs‚Äîwe use this layout because every neuron connects to every other, and a circle shows all 78 pairings clearly.) Colors show activation values: cyan for positive, pink for negative, with brightness indicating magnitude. The lines between neurons show synchronization strength‚Äîhow correlated each pair\'s activity has been across the ticks so far. Note: this is a toy model for learning. The original Sakana AI paper uses networks with 256‚Äì4096 neurons and 50‚Äì100 ticks.',
                        interaction: 'Drag to rotate the view. Scroll or use arrow keys to step through ticks. Click any neuron to inspect its internal network. The current tick appears larger and brighter.',
                        math: 'z^{t+1}_d = g_{\\theta_d}(A^t_d)',
                        mathLabel: 'Each neuron d computes its own activation'
                    },
                    networkDormant: {
                        title: 'Waiting to Think',
                        what: 'The network is dormant. No computation has run yet‚Äîthe neurons are idle and there\'s nothing to inspect.',
                        interaction: 'Enter an input sequence (or keep the default), then click Run to watch the CTM process it over 6 ticks. Once running, you can click neurons and connections to inspect their internals.'
                    },
                    ticks: {
                        title: 'Confidence Over Ticks',
                        what: 'CTMs iterate over multiple "ticks," refining their internal state. This chart shows confidence at each of our 6 ticks‚Äîtypically rising as neurons settle, though the model can "overthink" and waver.<br><br>Our fixed 6 ticks is an artificial constraint for visualization. In full-scale CTMs (50‚Äì100 ticks), genuine <em>adaptive computation</em> emerges: easy inputs cause quick settling into confident stability, while harder inputs keep the dynamics churning longer. There\'s no explicit "halt" signal‚Äîthe network simply stops changing its mind when confident. This is why CTMs train to find the best answer at <em>any</em> tick, not just the last.',
                        interaction: 'Use arrow keys or scroll wheel to step through ticks. Press P to jump to peak confidence. Watch how both the prediction and neural activity evolve‚Äîand notice if later ticks sometimes waver.',
                        math: 't \\in \\{1, 2, ..., T\\}',
                        mathLabel: 'Internal thinking steps'
                    },
                    detail: {
                        title: 'Neuron Detail View',
                        what: 'This is what makes CTMs unique: each neuron contains its own private neural network called a Neuron-Level Model (NLM). The top row shows the neuron\'s recent input history‚Äîits last 4 values. These feed through a small hidden layer (6 units with ReLU activation) to produce the single output value at bottom. Crucially, every neuron has different learned weights, so each one processes its history in its own way.',
                        interaction: 'Click different neurons to compare their internal networks‚Äînotice the connection colors (cyan=positive, pink=negative) and thickness (weight magnitude) vary between neurons. Step through ticks to see how each neuron\'s computation evolves.',
                        math: 'z_d = \\sigma(W^{(2)}_d \\cdot \\text{ReLU}(W^{(1)}_d \\cdot h_d))',
                        mathLabel: 'Neuron-Level Model with private weights Œ∏_d'
                    },
                    syncpair: {
                        title: 'Sync Pair Detail View',
                        what: 'A sync pair tracks how two neurons\' activity correlates over time. The sync value measures their temporal relationship with exponential decay‚Äîrecent agreement matters more than older history. The contribution chart below shows how all 78 pairs combine to form the final prediction: each pair\'s sync value is multiplied by a learned weight, and the sum of all 78 contributions equals the output.',
                        interaction: 'Click any row in the contribution chart to jump to that sync pair. Look for which pairs have the largest positive or negative contributions‚Äîthese are the relationships the model learned to care about most. Step through ticks to see how contributions shift as the network "thinks."',
                        math: 'y = \\sum_{i \\leq j} w_{ij} \\cdot S^t_{ij}',
                        mathLabel: 'Output = weighted sum of sync values'
                    },
                    detailEmpty: {
                        title: 'Detail View',
                        what: 'When you click a neuron or connection in the 3D visualization, this panel reveals what\'s happening inside. For neurons, you\'ll see its private neural network (the NLM). For connections, you\'ll see the sync pair\'s contribution to the final prediction alongside all 78 pairs ranked by influence.',
                        interaction: 'Click any neuron (sphere) or connection (line) in the 3D view to inspect it. The detail view updates as you step through ticks, showing how internal states evolve during the model\'s "thinking" process.'
                    }
                };
                
                const overlay = document.getElementById('explanationOverlay');
                const titleEl = document.getElementById('explanationTitle');
                const bodyEl = document.getElementById('explanationBody');
                const closeBtn = document.getElementById('explanationClose');
                
                const showExplanation = (key) => {
                    // Handle state-dependent detail panel explanation
                    if (key === 'detail') {
                        if (visualizer.selectedNeuron !== null) {
                            key = 'detail'; // Keep as neuron detail
                        } else if (visualizer.selectedConnection !== null) {
                            key = 'syncpair';
                        } else {
                            key = 'detailEmpty';
                        }
                    }
                    
                    const exp = explanations[key];
                    if (!exp) return;
                    
                    titleEl.textContent = exp.title;
                    
                    let mathHtml = '';
                    if (exp.math) {
                        mathHtml = `
                            <div class="explanation-math">
                                <span class="explanation-math-label">${exp.mathLabel || 'Formula'}</span>
                                <span id="mathContainer"></span>
                            </div>
                        `;
                    }
                    
                    bodyEl.innerHTML = `
                        <div class="explanation-section">
                            <h3>What it shows</h3>
                            <p>${exp.what}</p>
                            ${mathHtml}
                        </div>
                        <div class="explanation-section">
                            <h3>How to use it</h3>
                            <p>${exp.interaction}</p>
                        </div>
                    `;
                    
                    // Render math if present (need to wait for KaTeX to load)
                    if (exp.math) {
                        const mathContainer = document.getElementById('mathContainer');
                        if (mathContainer && typeof katex !== 'undefined') {
                            katex.render(exp.math, mathContainer, {
                                throwOnError: false,
                                displayMode: false
                            });
                        }
                    }
                    
                    overlay.classList.add('visible');
                };
                
                const hideExplanation = () => {
                    overlay.classList.remove('visible');
                    // Remove speech-bubble class if present
                    document.querySelector('.explanation-content').classList.remove('speech-bubble');
                };
                
                // Click handlers for all clickable elements
                document.querySelectorAll('[data-explain]').forEach(el => {
                    el.addEventListener('click', (e) => {
                        // Don't trigger if clicking on interactive elements
                        if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON' || e.target.tagName === 'CANVAS') {
                            return;
                        }
                        showExplanation(el.dataset.explain);
                    });
                });
                
                // Close handlers
                closeBtn.addEventListener('click', hideExplanation);
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) hideExplanation();
                });
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' || e.key === 'Enter') {
                        // Only close if overlay is actually visible
                        if (overlay.classList.contains('visible')) {
                            hideExplanation();
                            e.preventDefault(); // Prevent Enter from triggering other actions
                        }
                    }
                });
            }

            handleKeyDown(e) {
                if (e.target.tagName === 'INPUT') return;
                
                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        this.stepTick(-1);
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        this.stepTick(1);
                        break;
                    case ' ':
                        e.preventDefault();
                        this.togglePlay();
                        break;
                    case '1': case '2': case '3': case '4': case '5':
                        this.loadPreset(parseInt(e.key));
                        break;
                    case 'p': case 'P':
                        this.jumpToPrediction();
                        break;
                    case 'n': case 'N':
                        e.preventDefault();
                        this.startNewSequence();
                        break;
                }
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Handle drag rotation
                if (this.isDragging) {
                    const deltaX = e.clientX - this.lastMouseX;
                    const deltaY = e.clientY - this.lastMouseY;
                    
                    // Flip both directions so dragging feels like grabbing the front
                    this.rotationY -= deltaX * 0.5;
                    this.rotationX -= deltaY * 0.3;
                    
                    // Clamp rotations (Y: 20 to 80, starting at 50)
                    this.rotationY = Math.max(20, Math.min(80, this.rotationY));
                    this.rotationX = Math.max(-45, Math.min(-5, this.rotationX));
                    
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                    
                    this.updateProjectedPositions();
                    this.render();
                    return;
                }
                
                // In dormant state, show pointer for any neuron/connection hover
                if (!this.inferenceResult) {
                    const positions = this.neuronPositions3D[0];
                    if (positions) {
                        for (let i = 0; i < positions.length; i++) {
                            const pos = positions[i];
                            const dist = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
                            if (dist < 35) {
                                this.canvas.style.cursor = 'pointer';
                                return;
                            }
                        }
                        // Check connections
                        for (const conn of this.connectionPaths) {
                            if (conn.isSelf) continue;
                            const p1 = positions[conn.i];
                            const p2 = positions[conn.j];
                            const dist = this.pointToLineDistance(x, y, p1.x, p1.y, p2.x, p2.y);
                            if (dist < 10) {
                                this.canvas.style.cursor = 'pointer';
                                return;
                            }
                        }
                    }
                    this.canvas.style.cursor = 'grab';
                    return;
                }
                
                this.hoveredNeuron = null;
                this.hoveredConnection = null;
                
                // Only check current tick layer for hover
                const currentPositions = this.neuronPositions3D[this.currentTick];
                
                // Check neurons first
                for (let i = 0; i < currentPositions.length; i++) {
                    const pos = currentPositions[i];
                    const dist = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
                    if (dist < 30) {
                        this.hoveredNeuron = i;
                        this.canvas.style.cursor = 'pointer';
                        this.render();
                        return;
                    }
                }
                
                // Check connections on current tick
                for (const conn of this.connectionPaths) {
                    if (conn.isSelf) continue;
                    const p1 = currentPositions[conn.i];
                    const p2 = currentPositions[conn.j];
                    const dist = this.pointToLineDistance(x, y, p1.x, p1.y, p2.x, p2.y);
                    if (dist < 8) {
                        this.hoveredConnection = conn;
                        this.canvas.style.cursor = 'pointer';
                        this.render();
                        return;
                    }
                }
                
                this.canvas.style.cursor = this.isDragging ? 'grabbing' : 'grab';
                this.render();
            }

            pointToLineDistance(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let t = lenSq !== 0 ? dot / lenSq : -1;
                t = Math.max(0, Math.min(1, t));
                
                const nearestX = x1 + t * C;
                const nearestY = y1 + t * D;
                
                return Math.sqrt((px - nearestX) ** 2 + (py - nearestY) ** 2);
            }

            handleClick(e) {
                // In dormant state, any click on the network shows the welcome popup
                if (!this.inferenceResult) {
                    this.showDormantPopup();
                    return;
                }
                
                if (this.hoveredNeuron !== null) {
                    this.selectedNeuron = this.hoveredNeuron;
                    this.selectedConnection = null;
                    this.showNeuronDetail(this.selectedNeuron);
                } else if (this.hoveredConnection !== null) {
                    this.selectedConnection = this.hoveredConnection;
                    this.selectedNeuron = null;
                    this.showConnectionDetail(this.selectedConnection);
                } else {
                    this.selectedNeuron = null;
                    this.selectedConnection = null;
                    this.clearDetail();
                }
                this.render();
            }

            showDormantPopup() {
                const overlay = document.getElementById('explanationOverlay');
                const titleEl = document.getElementById('explanationTitle');
                const bodyEl = document.getElementById('explanationBody');
                const contentEl = document.querySelector('.explanation-content');
                
                titleEl.textContent = 'Waiting to Think';
                bodyEl.innerHTML = `
                    <div class="explanation-section">
                        <h3>What it shows</h3>
                        <p>The network is dormant. No computation has run yet‚Äîthe neurons are idle and there's nothing to inspect.</p>
                    </div>
                    <div class="explanation-section">
                        <h3>How to use it</h3>
                        <p>Enter an input sequence (or keep the default), then click <strong>Run</strong> to watch the CTM process it over 6 ticks. Once running, you can click neurons and connections to inspect their internals.</p>
                    </div>
                `;
                contentEl.classList.add('speech-bubble');
                overlay.classList.add('visible');
            }

            loadPreset(n) {
                document.querySelectorAll('.preset-key').forEach(k => k.classList.remove('active'));
                document.querySelector(`.preset-key[data-preset="${n}"]`).classList.add('active');
                
                // Generate a random sequence with step size n
                this.currentInput = this.generateRandomSequence(n);
                document.getElementById('input0').value = this.currentInput[0];
                document.getElementById('input1').value = this.currentInput[1];
                document.getElementById('input2').value = this.currentInput[2];
                
                this.executeRun();
            }

            loadFromInputFields() {
                const a = parseInt(document.getElementById('input0').value) || 1;
                const b = parseInt(document.getElementById('input1').value) || 2;
                const c = parseInt(document.getElementById('input2').value) || 3;
                
                document.querySelectorAll('.preset-key').forEach(k => k.classList.remove('active'));
                
                this.currentInput = [
                    Math.max(1, Math.min(55, a)),
                    Math.max(1, Math.min(55, b)),
                    Math.max(1, Math.min(55, c))
                ];
                
                // Update fields with clamped values
                document.getElementById('input0').value = this.currentInput[0];
                document.getElementById('input1').value = this.currentInput[1];
                document.getElementById('input2').value = this.currentInput[2];
            }

            async executeRun() {
                // Prevent multiple simultaneous runs
                if (this.isRunning) return;
                this.isRunning = true;
                
                const runButton = document.getElementById('runButton');
                runButton.disabled = true;
                
                // Stop any existing playback
                if (this.isPlaying) {
                    this.isPlaying = false;
                    clearInterval(this.playInterval);
                    document.getElementById('keySpace').classList.remove('active');
                }
                
                // Read values from input fields
                this.loadFromInputFields();
                
                // Run inference (compute all ticks upfront)
                this.inferenceResult = this.ctm.forward(this.currentInput, true);
                
                // Reset to show just first tick ring
                this.ticksRevealed = 1;
                
                // Animate through ticks, progressively revealing each layer
                for (let t = 0; t < this.maxTicks; t++) {
                    this.ticksRevealed = t + 1;  // Reveal this many rings
                    this.newestTickAlpha = 0;    // Start fade-in
                    this.setTick(t);
                    
                    // Animate fade-in of newest layer
                    const fadeStart = performance.now();
                    const fadeDuration = 150;
                    const fadeIn = () => {
                        const elapsed = performance.now() - fadeStart;
                        this.newestTickAlpha = Math.min(1, elapsed / fadeDuration);
                        this.render();
                        if (elapsed < fadeDuration) {
                            requestAnimationFrame(fadeIn);
                        }
                    };
                    fadeIn();
                    
                    // Pulse the button
                    runButton.classList.remove('running');
                    void runButton.offsetWidth; // Force reflow to restart animation
                    runButton.classList.add('running');
                    
                    // Wait between ticks (600ms for more visible progression)
                    await new Promise(resolve => setTimeout(resolve, 600));
                }
                
                // Find best tick (highest confidence) and jump to it
                const confidences = this.inferenceResult.internals.confidences;
                let maxConf = -1;
                let bestTick = 0;
                for (let t = 0; t < confidences.length; t++) {
                    if (confidences[t] > maxConf) {
                        maxConf = confidences[t];
                        bestTick = t;
                    }
                }
                this.setTick(bestTick);
                
                // Ensure all ticks remain visible for review mode
                this.ticksRevealed = this.maxTicks;
                this.newestTickAlpha = 1;
                this.render();
                
                runButton.classList.remove('running');
                runButton.disabled = false;
                this.isRunning = false;
            }

            runInference() {
                this.inferenceResult = this.ctm.forward(this.currentInput, true);
                this.updateUI();
            }

            stepTick(delta) {
                this.setTick(Math.max(0, Math.min(this.maxTicks - 1, this.currentTick + delta)));
            }

            setTick(tick) {
                this.currentTick = tick;
                this.updateProjectedPositions();
                this.updateUI();
                this.render();
            }

            jumpToPrediction() {
                if (!this.inferenceResult) return;
                
                // Find tick with maximum confidence (first one in case of tie)
                const confidences = this.inferenceResult.internals.confidences;
                let maxConf = -1;
                let bestTick = 0;
                
                for (let t = 0; t < confidences.length; t++) {
                    if (confidences[t] > maxConf) {
                        maxConf = confidences[t];
                        bestTick = t;
                    }
                }
                
                this.setTick(bestTick);
                
                // Brief highlight on the P button
                const btn = document.getElementById('keyPredict');
                btn.classList.add('active');
                setTimeout(() => btn.classList.remove('active'), 300);
            }

            startNewSequence() {
                // Brief highlight on the N button
                const btn = document.getElementById('keyNew');
                btn.classList.add('active');
                setTimeout(() => btn.classList.remove('active'), 300);
                
                // Focus the first input field
                const input0 = document.getElementById('input0');
                input0.focus();
                input0.select();
            }

            togglePlay() {
                // Edge case: if no inference has run yet, trigger the first Run
                if (!this.inferenceResult) {
                    this.executeRun();
                    return;
                }
                
                this.isPlaying = !this.isPlaying;
                document.getElementById('keySpace').classList.toggle('active', this.isPlaying);
                
                if (this.isPlaying) {
                    this.playInterval = setInterval(() => {
                        this.currentTick = (this.currentTick + 1) % this.maxTicks;
                        this.setTick(this.currentTick);
                    }, 800);
                } else {
                    clearInterval(this.playInterval);
                }
            }

            updateUI() {
                if (!this.inferenceResult) return;
                
                const tick = this.currentTick;
                const internals = this.inferenceResult.internals;
                
                const pred = internals.predictions[tick];
                const conf = internals.confidences[tick];
                
                document.getElementById('predictionBox').textContent = pred;
                document.getElementById('confidenceFill').style.width = (conf * 100) + '%';
                document.getElementById('confidenceText').textContent = (conf * 100).toFixed(1) + '%';
                
                const attnWeights = internals.attentionWeights[tick];
                this.updateAttentionDisplay(attnWeights);
                
                this.updateConfidenceChart();
                
                if (this.selectedNeuron !== null) {
                    this.showNeuronDetail(this.selectedNeuron);
                } else if (this.selectedConnection !== null) {
                    this.showConnectionDetail(this.selectedConnection);
                }
            }

            updateAttentionDisplay(attnWeights) {
                for (let h = 0; h < 2; h++) {
                    const container = document.getElementById(`attnHead${h}`);
                    const rows = container.querySelectorAll('.attention-row');
                    
                    for (let i = 0; i < 3; i++) {
                        const weight = attnWeights[h][i];
                        const row = rows[i];
                        row.querySelector('.attention-bar-fill').style.width = (weight * 100) + '%';
                        row.querySelector('.attention-weight').textContent = weight.toFixed(2);
                        row.querySelector('.attention-input-val').textContent = this.currentInput[i];
                    }
                }
                
                const avgAttn = attnWeights[0].map((w, i) => (w + attnWeights[1][i]) / 2);
                for (let i = 0; i < 3; i++) {
                    const inputEl = document.getElementById(`input${i}`);
                    inputEl.parentElement.querySelector('.attn-bar').style.width = (avgAttn[i] * 100) + '%';
                }
            }

            updateConfidenceChart() {
                const canvas = document.getElementById('confidenceChart');
                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                ctx.scale(dpr, dpr);
                
                const width = rect.width;
                const height = rect.height;
                const paddingLeft = 15;
                const paddingRight = 50;
                const paddingY = 20;
                const chartWidth = width - paddingLeft - paddingRight;
                const chartHeight = height - paddingY * 2;
                
                ctx.clearRect(0, 0, width, height);
                
                // Always draw baseline
                ctx.strokeStyle = '#2a3a4a';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(paddingLeft, height - paddingY);
                ctx.lineTo(width - paddingRight, height - paddingY);
                ctx.stroke();
                
                // If no inference yet, just show empty chart
                if (!this.inferenceResult) return;
                
                const confs = this.inferenceResult.internals.confidences;
                const stepX = chartWidth / (confs.length - 1);
                
                // Only draw up to ticksRevealed points
                const numPoints = Math.min(this.ticksRevealed, confs.length);
                
                // Draw line connecting revealed points
                if (numPoints > 1) {
                    ctx.strokeStyle = '#4a9eff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for (let i = 0; i < numPoints; i++) {
                        const x = paddingLeft + i * stepX;
                        const y = height - paddingY - confs[i] * chartHeight;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                // Draw dots for revealed points
                for (let i = 0; i < numPoints; i++) {
                    const x = paddingLeft + i * stepX;
                    const y = height - paddingY - confs[i] * chartHeight;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, i === this.currentTick ? 6 : 4, 0, Math.PI * 2);
                    ctx.fillStyle = i === this.currentTick ? '#00d4aa' : '#4a9eff';
                    ctx.fill();
                }
            }

            showNeuronDetail(neuronIdx) {
                const tick = this.currentTick;
                const internals = this.inferenceResult.internals;
                const activation = internals.postActivations[tick][neuronIdx];
                
                let html = `
                    <div class="detail-title">
                        <span class="neuron-label">Neuron ${neuronIdx}</span>
                        <span class="inline-output">
                            <span class="output-label-small">Output</span>
                            <span class="output-value-inline ${activation >= 0 ? 'positive' : 'negative'}">${activation.toFixed(4)}</span>
                        </span>
                        <span class="detail-close" onclick="visualizer.clearDetail()">‚úï</span>
                    </div>
                    <div class="nlm-diagram-container">
                        <canvas id="nlmCanvas"></canvas>
                    </div>
                    <div class="nlm-legend">
                        <div class="legend-item">
                            <span class="legend-color positive"></span>
                            <span>Positive</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color negative"></span>
                            <span>Negative</span>
                        </div>
                    </div>
                `;
                
                document.getElementById('detailPanel').innerHTML = html;
                
                // Render the NLM diagram after DOM update
                requestAnimationFrame(() => this.renderNLMDiagram(neuronIdx));
            }

            computeNLMHidden(neuronIdx, tick) {
                const internals = this.inferenceResult.internals;
                const history = internals.preActHistory[tick][neuronIdx];
                const nlmWeights = this.ctm.getNeuronNLMWeights(neuronIdx);
                const { memory_length, nlm_hidden } = this.ctm.config;
                
                const hidden = [];
                for (let hi = 0; hi < nlm_hidden; hi++) {
                    let sum = nlmWeights.b1[hi];
                    for (let mi = 0; mi < memory_length; mi++) {
                        sum += history[mi] * nlmWeights.w1[mi][hi];
                    }
                    hidden.push(Math.max(0, sum)); // ReLU
                }
                return hidden;
            }

            renderNLMDiagram(neuronIdx) {
                const canvas = document.getElementById('nlmCanvas');
                if (!canvas) return;
                
                const container = canvas.parentElement;
                const rect = container.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                canvas.style.width = rect.width + 'px';
                canvas.style.height = rect.height + 'px';
                
                const ctx = canvas.getContext('2d');
                ctx.scale(dpr, dpr);
                
                const width = rect.width;
                const height = rect.height;
                
                const tick = this.currentTick;
                const internals = this.inferenceResult.internals;
                const history = internals.preActHistory[tick][neuronIdx];
                const activation = internals.postActivations[tick][neuronIdx];
                const nlmWeights = this.ctm.getNeuronNLMWeights(neuronIdx);
                const hiddenValues = this.computeNLMHidden(neuronIdx, tick);
                
                // Layout parameters - scale with viewport
                const scale = this.neuronScale;
                const padding = 40 * scale;
                const nodeRadius = 32 * scale;
                const smallNodeRadius = 24 * scale;
                const layerSpacing = (height - padding * 2) / 3;
                
                // Y positions for each layer (with extra space for labels)
                const memoryY = padding + nodeRadius + 40;
                const hiddenY = memoryY + layerSpacing;
                const outputY = hiddenY + layerSpacing;
                
                // X positions for memory layer (4 nodes)
                const memoryNodes = [];
                const memorySpacing = (width - padding * 2) / 5;
                for (let i = 0; i < 4; i++) {
                    memoryNodes.push({
                        x: padding + memorySpacing * (i + 1),
                        y: memoryY,
                        value: history[i]
                    });
                }
                
                // X positions for hidden layer (6 nodes)
                const hiddenNodes = [];
                const hiddenSpacing = (width - padding * 2) / 7;
                for (let i = 0; i < 6; i++) {
                    hiddenNodes.push({
                        x: padding + hiddenSpacing * (i + 1),
                        y: hiddenY,
                        value: hiddenValues[i]
                    });
                }
                
                // Output node
                const outputNode = {
                    x: width / 2,
                    y: outputY,
                    value: activation
                };
                
                // Find max values for normalization
                const maxW1 = Math.max(...nlmWeights.w1.flat().map(Math.abs));
                const maxW2 = Math.max(...nlmWeights.w2.flat().map(Math.abs));
                const maxMemory = Math.max(...history.map(Math.abs), 0.1);
                const maxHidden = Math.max(...hiddenValues.map(Math.abs), 0.1);
                
                // Draw connections: Memory -> Hidden (W1)
                for (let mi = 0; mi < 4; mi++) {
                    for (let hi = 0; hi < 6; hi++) {
                        const weight = nlmWeights.w1[mi][hi];
                        const normalizedWeight = Math.abs(weight) / maxW1;
                        
                        const alpha = 0.15 + normalizedWeight * 0.6;
                        const lineWidth = 0.75 + normalizedWeight * 3;
                        const hue = weight >= 0 ? 175 : 340; // cyan or pink
                        
                        ctx.strokeStyle = `hsla(${hue}, 80%, 55%, ${alpha})`;
                        ctx.lineWidth = lineWidth;
                        ctx.beginPath();
                        ctx.moveTo(memoryNodes[mi].x, memoryNodes[mi].y + smallNodeRadius);
                        ctx.lineTo(hiddenNodes[hi].x, hiddenNodes[hi].y - smallNodeRadius);
                        ctx.stroke();
                    }
                }
                
                // Draw connections: Hidden -> Output (W2)
                for (let hi = 0; hi < 6; hi++) {
                    const weight = nlmWeights.w2[hi][0];
                    const normalizedWeight = Math.abs(weight) / maxW2;
                    
                    const alpha = 0.2 + normalizedWeight * 0.7;
                    const lineWidth = 0.75 + normalizedWeight * 3.5;
                    const hue = weight >= 0 ? 175 : 340;
                    
                    ctx.strokeStyle = `hsla(${hue}, 80%, 55%, ${alpha})`;
                    ctx.lineWidth = lineWidth;
                    ctx.beginPath();
                    ctx.moveTo(hiddenNodes[hi].x, hiddenNodes[hi].y + smallNodeRadius);
                    ctx.lineTo(outputNode.x, outputNode.y - nodeRadius);
                    ctx.stroke();
                }
                
                // Draw layer labels (rotated -90 degrees, centered with each layer)
                ctx.font = '20px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = '#6a7a8a';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const labelX = 20;  // Fixed X position for vertical alignment
                
                ctx.save();
                ctx.translate(labelX, memoryY);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('MEMORY', 0, 0);
                ctx.restore();
                
                ctx.save();
                ctx.translate(labelX, hiddenY);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('HIDDEN', 0, 0);
                ctx.restore();
                
                ctx.save();
                ctx.translate(labelX, outputY);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('OUTPUT', 0, 0);
                ctx.restore();
                
                // Draw memory nodes
                for (let i = 0; i < 4; i++) {
                    const node = memoryNodes[i];
                    const normalizedVal = Math.abs(node.value) / maxMemory;
                    const brightness = 25 + normalizedVal * 35;
                    const hue = node.value >= 0 ? 175 : 340;
                    
                    // Node glow
                    if (normalizedVal > 0.3) {
                        const gradient = ctx.createRadialGradient(
                            node.x, node.y, smallNodeRadius * 0.5,
                            node.x, node.y, smallNodeRadius * 2
                        );
                        gradient.addColorStop(0, `hsla(${hue}, 80%, 50%, ${normalizedVal * 0.3})`);
                        gradient.addColorStop(1, `hsla(${hue}, 80%, 50%, 0)`);
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, smallNodeRadius * 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Node body
                    ctx.fillStyle = `hsl(${hue}, 60%, ${brightness}%)`;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, smallNodeRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Node border
                    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Value label
                    ctx.fillStyle = '#fff';
                    ctx.font = '14px SF Mono, Consolas, monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(node.value.toFixed(1), node.x, node.y);
                    
                    // Index label above
                    ctx.fillStyle = '#6a7a8a';
                    ctx.font = '13px SF Mono, Consolas, monospace';
                    ctx.fillText(`t-${3-i}`, node.x, node.y - smallNodeRadius - 12);
                }
                
                // Draw hidden nodes
                for (let i = 0; i < 6; i++) {
                    const node = hiddenNodes[i];
                    const normalizedVal = Math.abs(node.value) / maxHidden;
                    const brightness = 25 + normalizedVal * 35;
                    const hue = node.value >= 0 ? 175 : 340;
                    
                    // Node glow for active hidden units
                    if (node.value > 0 && normalizedVal > 0.2) {
                        const gradient = ctx.createRadialGradient(
                            node.x, node.y, smallNodeRadius * 0.5,
                            node.x, node.y, smallNodeRadius * 2
                        );
                        gradient.addColorStop(0, `hsla(${hue}, 80%, 50%, ${normalizedVal * 0.4})`);
                        gradient.addColorStop(1, `hsla(${hue}, 80%, 50%, 0)`);
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, smallNodeRadius * 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Node body - darker if ReLU killed it
                    const saturation = node.value > 0 ? 60 : 20;
                    const actualBrightness = node.value > 0 ? brightness : 20;
                    ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${actualBrightness}%)`;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, smallNodeRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Node border
                    ctx.strokeStyle = node.value > 0 ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.1)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Value label
                    ctx.fillStyle = node.value > 0 ? '#fff' : '#666';
                    ctx.font = '14px SF Mono, Consolas, monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(node.value.toFixed(1), node.x, node.y);
                }
                
                // Draw output node (larger)
                const outNorm = Math.min(Math.abs(outputNode.value) / 2, 1);
                const outBrightness = 30 + outNorm * 40;
                const outHue = outputNode.value >= 0 ? 175 : 340;
                
                // Output glow
                const outGradient = ctx.createRadialGradient(
                    outputNode.x, outputNode.y, nodeRadius * 0.5,
                    outputNode.x, outputNode.y, nodeRadius * 2.5
                );
                outGradient.addColorStop(0, `hsla(${outHue}, 80%, 50%, ${0.2 + outNorm * 0.3})`);
                outGradient.addColorStop(1, `hsla(${outHue}, 80%, 50%, 0)`);
                ctx.fillStyle = outGradient;
                ctx.beginPath();
                ctx.arc(outputNode.x, outputNode.y, nodeRadius * 2.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Output node body
                ctx.fillStyle = `hsl(${outHue}, 70%, ${outBrightness}%)`;
                ctx.beginPath();
                ctx.arc(outputNode.x, outputNode.y, nodeRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Output border
                ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Output value
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 16px SF Mono, Consolas, monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(outputNode.value.toFixed(2), outputNode.x, outputNode.y);
            }

            showConnectionDetail(conn) {
                const tick = this.currentTick;
                const internals = this.inferenceResult.internals;
                const syncValue = internals.sync[tick][conn.syncIndex];
                const pairInfo = this.ctm.getSyncPairInfo(conn.syncIndex);
                
                const actI = internals.postActivations[tick][conn.i];
                const actJ = internals.postActivations[tick][conn.j];
                
                let html = `
                    <div class="detail-title">
                        <span>Sync Pair ${conn.i}‚Æú‚Æû${conn.j}</span>
                        <span class="detail-close" onclick="visualizer.clearDetail()">‚úï</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Sync Value</span>
                        <span class="detail-value">${syncValue.toFixed(4)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Decay Rate</span>
                        <span class="detail-value">${pairInfo.decayRate.toFixed(4)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Neuron ${conn.i} activation</span>
                        <span class="detail-value">${actI.toFixed(4)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Neuron ${conn.j} activation</span>
                        <span class="detail-value">${actJ.toFixed(4)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Product (current)</span>
                        <span class="detail-value">${(actI * actJ).toFixed(4)}</span>
                    </div>
                    <div style="margin-top: 12px; font-size: 11px; color: var(--text-dim);">
                        Sync = weighted correlation of activations over time, with exponential decay (rate ${pairInfo.decayRate.toFixed(2)})
                    </div>
                    <div class="contribution-chart-section">
                        <div class="contribution-chart-title">Contribution to Prediction (all 78 pairs)</div>
                        <div class="contribution-chart-container" id="contributionChart"></div>
                    </div>
                `;
                
                document.getElementById('detailPanel').innerHTML = html;
                
                // Render contribution chart
                requestAnimationFrame(() => this.renderContributionChart(conn.syncIndex));
            }
            
            renderContributionChart(selectedSyncIndex) {
                const container = document.getElementById('contributionChart');
                if (!container) return;
                
                const tick = this.currentTick;
                const internals = this.inferenceResult.internals;
                const syncValues = internals.sync[tick];
                const outputWeights = this.ctm.weights.output_proj_weight[0]; // First (only) output
                
                // Calculate contribution for each sync pair
                const contributions = [];
                for (let i = 0; i < syncValues.length; i++) {
                    const pairInfo = this.ctm.getSyncPairInfo(i);
                    contributions.push({
                        index: i,
                        neuronI: pairInfo.neuronI,
                        neuronJ: pairInfo.neuronJ,
                        syncValue: syncValues[i],
                        weight: outputWeights[i],
                        contribution: syncValues[i] * outputWeights[i],
                        isSelf: pairInfo.isSelf
                    });
                }
                
                // Sort by absolute contribution (most influential first)
                contributions.sort((a, b) => Math.abs(b.contribution) - Math.abs(a.contribution));
                
                // Find max for scaling
                const maxContrib = Math.max(...contributions.map(c => Math.abs(c.contribution)));
                
                // Build HTML for scrollable bar chart
                let chartHtml = '';
                for (const c of contributions) {
                    const isSelected = c.index === selectedSyncIndex;
                    const barWidth = maxContrib > 0 ? (Math.abs(c.contribution) / maxContrib) * 100 : 0;
                    const isPositive = c.contribution >= 0;
                    const pairLabel = c.neuronI === c.neuronJ ? `${c.neuronI}‚Üî${c.neuronJ}` : `${c.neuronI}‚Üî${c.neuronJ}`;
                    
                    chartHtml += `
                        <div class="contrib-row ${isSelected ? 'selected' : ''}" data-sync-index="${c.index}">
                            <span class="contrib-pair">${pairLabel}</span>
                            <div class="contrib-bar-container">
                                <div class="contrib-bar ${isPositive ? 'positive' : 'negative'}" style="width: ${barWidth}%"></div>
                            </div>
                            <span class="contrib-value ${isPositive ? 'positive' : 'negative'}">${c.contribution >= 0 ? '+' : ''}${c.contribution.toFixed(3)}</span>
                        </div>
                    `;
                }
                
                container.innerHTML = chartHtml;
                
                // Add click handlers to switch to different sync pairs
                container.querySelectorAll('.contrib-row').forEach(row => {
                    row.addEventListener('click', () => {
                        const syncIndex = parseInt(row.dataset.syncIndex);
                        const conn = this.connectionPaths.find(c => c.syncIndex === syncIndex);
                        if (conn) {
                            this.selectedConnection = conn;
                            this.selectedNeuron = null;
                            this.showConnectionDetail(conn);
                            this.render();
                        }
                    });
                });
                
                // Scroll to selected item
                const selectedRow = container.querySelector('.contrib-row.selected');
                if (selectedRow) {
                    selectedRow.scrollIntoView({ block: 'center', behavior: 'smooth' });
                }
            }

            clearDetail() {
                this.selectedNeuron = null;
                this.selectedConnection = null;
                document.getElementById('detailPanel').innerHTML = `
                    <div style="color: var(--text-secondary); font-size: 16px;">
                        Click a neuron or connection to inspect
                    </div>
                `;
                this.render();
            }

            render() {
                const ctx = this.ctx;
                const width = this.canvasWidth;
                const height = this.canvasHeight;
                
                ctx.clearRect(0, 0, width, height);
                
                // Pre-run dormant state: draw single ring of neutral neurons with connections
                if (!this.inferenceResult) {
                    const positions = this.neuronPositions3D[0];
                    if (!positions) return;
                    
                    // Draw connections in neutral state
                    for (const conn of this.connectionPaths) {
                        if (conn.isSelf) continue;
                        
                        const p1 = positions[conn.i];
                        const p2 = positions[conn.j];
                        
                        ctx.strokeStyle = 'rgba(100, 120, 140, 0.15)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    }
                    
                    // Draw neurons
                    for (let i = 0; i < 12; i++) {
                        const pos = positions[i];
                        const scale = this.neuronScale;
                        const radius = 30 * scale;  // 50% larger than before (was 20), scaled
                        
                        // Subtle glow for dormant neurons
                        const gradient = ctx.createRadialGradient(pos.x, pos.y, radius, pos.x, pos.y, radius + 15 * scale);
                        gradient.addColorStop(0, 'rgba(74, 158, 255, 0.15)');
                        gradient.addColorStop(1, 'rgba(74, 158, 255, 0)');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, radius + 15 * scale, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Dormant neuron body - neutral grey-blue
                        ctx.fillStyle = 'hsla(210, 30%, 35%, 0.8)';
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Border
                        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        
                        // Label
                        ctx.fillStyle = 'rgba(255,255,255,0.7)';
                        ctx.font = `${16 * scale}px SF Mono, Consolas, monospace`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(i.toString(), pos.x, pos.y);
                    }
                    
                    // t1 label
                    const bottomNeuron = positions.reduce((best, p) => p.y > best.y ? p : best, positions[0]);
                    const centerX = positions.reduce((sum, p) => sum + p.x, 0) / positions.length;
                    ctx.font = 'bold 16px SF Mono, Consolas, monospace';
                    ctx.fillStyle = 'rgba(120, 140, 160, 0.5)';
                    ctx.textAlign = 'center';
                    ctx.fillText('t1', centerX, bottomNeuron.y + 45);
                    
                    return;
                }
                
                const currentTick = this.currentTick;
                const internals = this.inferenceResult.internals;
                
                // Collect all renderable items with depth for sorting
                const renderItems = [];
                
                // Build render items for each REVEALED tick layer
                for (let tick = 0; tick < this.ticksRevealed; tick++) {
                    const isCurrentTick = tick === currentTick;
                    const isNewestTick = tick === this.ticksRevealed - 1;
                    
                    // Base layer alpha: current tick bright, others dim
                    let layerAlpha = isCurrentTick ? 1.0 : 0.15;
                    
                    // Apply fade-in for newest tick during animation
                    if (isNewestTick && this.newestTickAlpha < 1) {
                        layerAlpha *= this.newestTickAlpha;
                    }
                    
                    const positions = this.neuronPositions3D[tick];
                    
                    const syncValues = internals.sync[tick];
                    const activations = internals.postActivations[tick];
                    const maxSync = Math.max(...syncValues.map(Math.abs));
                    const maxAct = Math.max(...activations.map(Math.abs));
                    
                    // Average depth of this layer for sorting
                    const layerDepth = positions.reduce((sum, p) => sum + p.depth, 0) / positions.length;
                    
                    // Add connections for this tick
                    for (const conn of this.connectionPaths) {
                        if (conn.isSelf) continue;
                        
                        const p1 = positions[conn.i];
                        const p2 = positions[conn.j];
                        const syncVal = syncValues[conn.syncIndex];
                        const normalizedSync = maxSync > 0 ? Math.abs(syncVal) / maxSync : 0;
                        
                        const isSelected = isCurrentTick && this.selectedConnection && 
                                           this.selectedConnection.syncIndex === conn.syncIndex;
                        const isHovered = isCurrentTick && this.hoveredConnection && 
                                          this.hoveredConnection.syncIndex === conn.syncIndex;
                        
                        renderItems.push({
                            type: 'connection',
                            depth: (p1.depth + p2.depth) / 2,
                            tick,
                            draw: () => {
                                let alpha = (0.1 + normalizedSync * 0.6) * layerAlpha;
                                let lineWidth = 1.5 + normalizedSync * 4;
                                
                                if (isSelected || isHovered) {
                                    alpha = 1;
                                    lineWidth += 2;
                                }
                                
                                const hue = syncVal >= 0 ? 175 : 340;
                                ctx.strokeStyle = `hsla(${hue}, 80%, 60%, ${alpha})`;
                                ctx.lineWidth = lineWidth;
                                
                                ctx.beginPath();
                                ctx.moveTo(p1.x, p1.y);
                                ctx.lineTo(p2.x, p2.y);
                                ctx.stroke();
                            }
                        });
                    }
                    
                    // Add neurons for this tick
                    for (let i = 0; i < 12; i++) {
                        const pos = positions[i];
                        const act = activations[i];
                        const normalizedAct = maxAct > 0 ? Math.abs(act) / maxAct : 0;
                        
                        const selfSyncIdx = this.connectionPaths.findIndex(c => c.i === i && c.j === i);
                        const selfSync = selfSyncIdx >= 0 ? syncValues[selfSyncIdx] : 0;
                        
                        const isSelected = isCurrentTick && this.selectedNeuron === i;
                        const isHovered = isCurrentTick && this.hoveredNeuron === i;
                        
                        renderItems.push({
                            type: 'neuron',
                            depth: pos.depth,
                            tick,
                            draw: () => {
                                const scale = this.neuronScale;
                                const baseRadius = (isCurrentTick ? 26 : 18) + normalizedAct * (isCurrentTick ? 12 : 5);
                                const radius = baseRadius * scale;
                                const glowRadius = radius + (22 + Math.abs(selfSync) * 0.6) * scale;
                                
                                // Glow for self-sync (current tick only)
                                if (isCurrentTick && selfSync > 0) {
                                    const gradient = ctx.createRadialGradient(pos.x, pos.y, radius, pos.x, pos.y, glowRadius);
                                    gradient.addColorStop(0, `rgba(74, 158, 255, ${0.3 * layerAlpha})`);
                                    gradient.addColorStop(1, 'rgba(74, 158, 255, 0)');
                                    ctx.fillStyle = gradient;
                                    ctx.beginPath();
                                    ctx.arc(pos.x, pos.y, glowRadius, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                                
                                // Selection/hover ring (current tick only)
                                if (isSelected || isHovered) {
                                    ctx.strokeStyle = '#4a9eff';
                                    ctx.lineWidth = 3 * scale;
                                    ctx.beginPath();
                                    ctx.arc(pos.x, pos.y, radius + 6 * scale, 0, Math.PI * 2);
                                    ctx.stroke();
                                }
                                
                                // Neuron body
                                const brightness = 30 + normalizedAct * 40;
                                const hue = act >= 0 ? 210 : 340;
                                ctx.fillStyle = `hsla(${hue}, 60%, ${brightness}%, ${layerAlpha})`;
                                ctx.beginPath();
                                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                                ctx.fill();
                                
                                // Border
                                ctx.strokeStyle = `rgba(255,255,255,${0.3 * layerAlpha})`;
                                ctx.lineWidth = 1;
                                ctx.stroke();
                                
                                // Label (only on current tick or if neurons are big enough)
                                if (isCurrentTick || radius > 14 * scale) {
                                    ctx.fillStyle = `rgba(255,255,255,${layerAlpha})`;
                                    ctx.font = `${(isCurrentTick ? 16 : 11) * scale}px SF Mono, Consolas, monospace`;
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'middle';
                                    ctx.fillText(i.toString(), pos.x, pos.y);
                                }
                            }
                        });
                    }
                    
                    // Add tick label for this layer
                    if (positions.length > 0) {
                        // Position label below each layer (find bottommost neuron)
                        const bottomNeuron = positions.reduce((best, p) => p.y > best.y ? p : best, positions[0]);
                        // Also get center X of this layer
                        const centerX = positions.reduce((sum, p) => sum + p.x, 0) / positions.length;
                        
                        renderItems.push({
                            type: 'label',
                            depth: layerDepth - 1000, // Draw labels behind
                            tick,
                            draw: () => {
                                const labelX = centerX;
                                const labelY = bottomNeuron.y + 40;
                                
                                ctx.font = `${isCurrentTick ? 'bold 16px' : '13px'} SF Mono, Consolas, monospace`;
                                ctx.fillStyle = isCurrentTick ? '#4a9eff' : `rgba(120, 140, 160, ${layerAlpha * 2})`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(`t${tick + 1}`, labelX, labelY);
                            }
                        });
                    }
                }
                
                // Sort by depth (back to front)
                renderItems.sort((a, b) => a.depth - b.depth);
                
                // Render all items
                for (const item of renderItems) {
                    item.draw();
                }
            }
        }

        // Initialize
        let visualizer;
        
        // Adjust prediction label if row is too wide for left panel
        function adjustPredictionLabel() {
            const leftPanel = document.querySelector('.left-panel');
            const predConfRow = document.getElementById('predConfRow');
            const predTitle = document.getElementById('predictionTitle');
            const predPanel = document.getElementById('predictionPanel');
            
            if (!leftPanel || !predConfRow || !predTitle || !predPanel) return;
            
            // Get the available width (left panel width minus padding/scrollbar)
            const leftPanelStyle = getComputedStyle(leftPanel);
            const availableWidth = leftPanel.clientWidth - 
                parseFloat(leftPanelStyle.paddingLeft) - 
                parseFloat(leftPanelStyle.paddingRight);
            
            // Get the row's natural width
            const rowGap = parseFloat(getComputedStyle(predConfRow).gap) || 12;
            const panels = predConfRow.querySelectorAll('.panel-half');
            let totalWidth = rowGap; // gap between panels
            panels.forEach(p => {
                totalWidth += p.offsetWidth;
            });
            
            // If row is too wide, shrink prediction label and panel
            if (totalWidth > availableWidth) {
                predTitle.textContent = 'Pred.';
                predPanel.style.flex = '0 0 auto';
                predPanel.style.minWidth = '80px';
            } else {
                predTitle.textContent = 'Prediction';
                predPanel.style.flex = '1';
                predPanel.style.minWidth = '';
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            visualizer = new CTMVisualizer();
            visualizer.init();
            
            // Initial check and on resize
            adjustPredictionLabel();
            window.addEventListener('resize', adjustPredictionLabel);
        });
    </script>
</body>
</html>
